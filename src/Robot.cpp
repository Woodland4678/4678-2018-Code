// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include <math.h>

#include "Robot.h"

#include "rplidar.h"

#ifndef _countof
#define _countof(_Array) (int)(sizeof(_Array) / sizeof(_Array[0]))
#endif

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<DriveTrain> Robot::driveTrain;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

using namespace rp::standalone::rplidar;

RPlidarDriver * drv;

void initRPlidarDriver() {
	drv = RPlidarDriver::CreateDriver(RPlidarDriver::DRIVER_TYPE_SERIALPORT);
	printf("Connecting to rplidar\n");
	if(!drv->connect("/dev/ttyUSB0", 115200)) {
		printf("Connected to rplidar\n");
		rplidar_response_device_info_t devinfo;
		if(!drv->getDeviceInfo(devinfo)) {
			printf("RPLIDAR S/N: ");
			for (int pos = 0; pos < 16 ;++pos) {
				printf("%02X", devinfo.serialnum[pos]);
			}

			printf("\n"
					"Version: "RPLIDAR_SDK_VERSION"\n"
					"Firmware Ver: %d.%02d\n"
					"Hardware Rev: %d\n"
					, devinfo.firmware_version>>8
					, devinfo.firmware_version & 0xFF
					, (int)devinfo.hardware_version);
		} else {
			fprintf(stderr, "Error, cannot get device info\n");
		}

		rplidar_response_device_health_t healthinfo;

		// check the device health
		////////////////////////////////////////
		if (!drv->getHealth(healthinfo)) { // the macro IS_OK is the preperred way to judge whether the operation is succeed.
			printf("RPLidar health status : ");
			switch (healthinfo.status) {
			case RPLIDAR_STATUS_OK:
				printf("OK.");
				break;
			case RPLIDAR_STATUS_WARNING:
				printf("Warning.");
				break;
			case RPLIDAR_STATUS_ERROR:
				printf("Error.");
				break;
			}
			printf(" (errorcode: %d)\n", healthinfo.error_code);

		} else {
			fprintf(stderr, "Error, cannot retrieve the lidar health\n");
			return;
		}


		if (healthinfo.status == RPLIDAR_STATUS_ERROR) {
			fprintf(stderr, "Error, rplidar internal error detected. Please reboot the device to retry.\n");
			// enable the following code if you want rplidar to be reboot by software
			// drv->reset()
			return;
		}
	} else {
		fprintf(stderr, "Error, cannot connect to lidar\n");
	}
}

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    driveTrain.reset(new DriveTrain());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	// Add commands to Autonomous Sendable Chooser
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS


	chooser.AddDefault("Autonomous Command", new AutonomousCommand());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	frc::SmartDashboard::PutData("Auto Modes", &chooser);
}

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	if (drv) {
		drv->stopMotor();
		drv->disconnect();
		RPlidarDriver::DisposeDriver(drv);
	}
}

void Robot::DisabledPeriodic() {
	frc::Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit() {
	autonomousCommand = chooser.GetSelected();
	if (autonomousCommand != nullptr)
		autonomousCommand->Start();
}

void Robot::AutonomousPeriodic() {
	frc::Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() {
	initRPlidarDriver();
	drv->startMotor();
	drv->startScan();
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	done = false;
	if (autonomousCommand != nullptr)
		autonomousCommand->Cancel();
}

void Robot::TeleopPeriodic() {

	rplidar_response_measurement_node_t nodes[360*2];
	size_t count = _countof(nodes);

	if (!drv->grabScanData(nodes, count)) {
		drv->ascendScanData(nodes, count);

		for (unsigned int i = 0; i < count; ++i) {
			double rad = M_PI * ((nodes[i].angle_q6_checkbit >> RPLIDAR_RESP_MEASUREMENT_ANGLE_SHIFT)/64.0f) / 180;
			if (nodes[i].distance_q2) {
				int x = (nodes[i].distance_q2/4.0f) * std::sin(rad);
				int y = (nodes[i].distance_q2/4.0f) * std::cos(rad);
				printf("(%d, %d)", x, y);
			}
		}
		printf("\n");
	}

	if((oi->driver->GetRawButton(1))&&(!done))
		{

		frc::Scheduler::GetInstance()->Run();
		double leftEnValue = driveTrain->leftEncoder->Get();
		frc::SmartDashboard::PutNumber("Left Encoder Value",leftEnValue);
		double rightEnValue = driveTrain->rightEncoder->Get();
		frc::SmartDashboard::PutNumber("Right Encoder Value",rightEnValue);

		//done = driveTrain->goToDistance(50,75,1,10,10,0.5,0.5);
		}
	frc::SmartDashboard::PutNumber("Done",done);
}

START_ROBOT_CLASS(Robot);

