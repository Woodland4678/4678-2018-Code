// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include <sstream>

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<DriveTrain> Robot::driveTrain;
std::shared_ptr<Lidar> Robot::lidar;
std::shared_ptr<ManipulatorArm> Robot::manipulatorArm;
std::shared_ptr<ScaleDetection> Robot::scaleDetection;
std::shared_ptr<Intake> Robot::intake;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
AHRS * Robot::ahrs;
frc::CameraServer * usbCam;

char  Robot::ms_ourSwitchSide = 'a';
char  Robot::ms_ourScaleSide  = 'a';
bool Robot::isAuto = false;

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    driveTrain.reset(new DriveTrain());
    lidar.reset(new Lidar());
    manipulatorArm.reset(new ManipulatorArm());
    scaleDetection.reset(new ScaleDetection());
    intake.reset(new Intake());
	ahrs = new AHRS(SPI::Port::kMXP);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	// Add commands to Autonomous Sendable Chooser

	usbCam->GetInstance()->StartAutomaticCapture();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

	autonomousCommand = new AutonomousCommand();
//	chooser.AddDefault("Autonomous Command", new AutonomousCommand());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	frc::SmartDashboard::PutData("Auto Modes", &chooser);
	bool armGood = manipulatorArm->Init();
	if(!armGood)
		armGood = manipulatorArm->Init(); //Second attempt!
	frc::SmartDashboard::PutBoolean("Robot Good", armGood);
}

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	lidar->stopLidar();
	manipulatorArm->closeLog();
}

void Robot::DisabledPeriodic() {
	frc::Scheduler::GetInstance()->Run();

	const std::string game_data = frc::DriverStation::GetInstance().GetGameSpecificMessage();
	if (game_data.length() > 0) {
		ms_ourSwitchSide = game_data[0];
		ms_ourScaleSide = game_data[1];
	}
}

void Robot::AutonomousInit() {
	//manipulatorArm->Init();
	lidar->startLidar();
//	//boundaryCheck->Set(frc::Relay::Value::kReverse);
//	printf("Starting Auto\n");
//	autonomousCommand = chooser.GetSelected();
//	if (autonomousCommand != nullptr)
//		{
//		printf("Command Found\n");
//		autonomousCommand->Start();
//		}
//	else
//		printf("No Cammand\n");
	if (autonomousCommand != NULL) {
		autonomousCommand->Start();
	}
}

void Robot::AutonomousPeriodic() {
	manipulatorArm->updateArm();
	frc::Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() {
	//manipulatorArm->Init();
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	cnt = 0;

	done = false;
	caseThing = 0;

	if (autonomousCommand != nullptr)
		autonomousCommand->Cancel();

	manipulatorArm->updateArm();
	manipulatorArm->pickUpCase = 0;

	//Arm recording:
	manipulatorArm->openLog();


	//TODO: re-enable this!
	lidar->startLidar();

}

void Robot::TeleopPeriodic() {
	frc::Scheduler::GetInstance()->Run();
	cnt++;
	//Robot Checks
	frc::SmartDashboard::PutNumber("Gryo angle", Robot::ahrs->GetAngle());

	manipulatorArm->updateArm();
	intake->updateEndEffector();

	//Display arm location for operator
	frc::SmartDashboard::PutString("Arm Current", manipulatorArm->getPositionStr(manipulatorArm->currPos));
	frc::SmartDashboard::PutString("Arm Target", manipulatorArm->getPositionStr(manipulatorArm->targetPos));
	frc::SmartDashboard::PutString("Intake Current", intake->getPositionSting(intake->checkPosition()));

	if(driveTrain->readCompressor() > 0)
		frc::SmartDashboard::PutBoolean("Compressor", true);
	else
		frc::SmartDashboard::PutBoolean("Compressor", false);


	/*if(!done)
		{
		done = lidar->findCubes();
		if(done == 2)
			frc::SmartDashboard::PutBoolean("Cube Found", false);
		}*/
	//scaleDetection->GetScalePosition();
	/*if ((manipulatorArm->endEffectorX > 32))
		{
		//std::stringstream  text_stream;
		//text_stream << "Position: " << manipulatorArm->targetPos << "\n";
		//text_stream << "Previous Position: " << manipulatorArm->prevPos << "\n\n";
		//fwrite(text_stream.str().c_str(),1, text_stream.str().length(), data);

		//Turn on relay
		boundaryCheck->Set(frc::Relay::Value::kForward);
		cnt = 0;
		}
	if (manipulatorArm->endEffectorX < -32)
	{
		boundaryCheck->Set(frc::Relay::Value::kReverse);
		cnt = 0;
	}
	if(cnt > 50)
		boundaryCheck->Set(frc::Relay::Value::kOff);
	*/
//	if (oi->getdriver()->GetRawButton(1)) {
//
//		//driveTrain->goToDistance(548, 548, 1);
//		//intake->grab();
//
//		double p = frc::SmartDashboard::GetNumber("p factor",1);
//		double i = frc::SmartDashboard::GetNumber("i factor",0);
//		double d = frc::SmartDashboard::GetNumber("d factor",0);
//		double zone = frc::SmartDashboard::GetNumber("zone factor",10);
//
//		manipulatorArm->setShoulderPID(p, i, d);
//		frc::SmartDashboard::PutString("PID", "Changed");
//	}
//	else
//		frc::SmartDashboard::PutString("PID", "Same");
//	manipulatorArm->updateArm();
//	if (oi->getoperate()->GetRawButton(5) && !done) {
//		double joyY = oi->getoperate()->GetRawAxis(1);
//		if (cnt < 5)
//			manipulatorArm->fineMovement(joyY, 0);
//		if(cnt > 20)
//			cnt = 0;
//	}
//	if (oi->getdriver()->GetRawButton(9)) {
//		intake->setRightSpeed(0);
//		intake->setLeftSpeed(0);
//	}
//	if (oi->getdriver()->GetRawButton(4)) {
//		intake->setRightSpeed(0.5);
//		intake->setLeftSpeed(0.5);
//	}
//	if (oi->getdriver()->GetRawButton(7)) {
//		manipulatorArm->squeeze();
//	}
//	if (oi->getdriver()->GetRawButton(8)) {
//		manipulatorArm->release();
//	}
//	if (oi->getdriver()->GetRawButton(1)) {
//		intake->grab();
//	}
//	if (oi->getdriver()->GetRawButton(4)) {
//		intake->release();
//	}
	/*if (oi->getdriver()->GetRawButton(4)) {
		Robot::manipulatorArm->release();
	}
	if (oi->getdriver()->GetRawButton(3)) {
		Robot::manipulatorArm->squeeze();
	}*/


	/*if ((oi->getdriver()->GetRawButton(1)) && (!done)) { //hold button down
		switch(caseThing){
			case 0:
				Robot::manipulatorArm->initMovement();
				caseThing++;
				break;
			case 1:
				done = Robot::manipulatorArm->pickUpCube();
				break;
		}

	}*/
}


START_ROBOT_CLASS(Robot);

