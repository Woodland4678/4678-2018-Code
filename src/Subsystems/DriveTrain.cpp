// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.



#include <stdio.h>
#include "DriveTrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/DriveTrainC.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

DriveTrain::DriveTrain() : frc::Subsystem("DriveTrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMotor = RobotMap::driveTrainLeftMotor;
    rightMotor = RobotMap::driveTrainRightMotor;
    rightEncoder = RobotMap::driveTrainrightEncoder;
    leftEncoder = RobotMap::driveTrainleftEncoder;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftEncoder->SetPIDSourceType(PIDSourceType::kRate);
	leftEncoder->SetDistancePerPulse(1.0);

	rightEncoder->SetPIDSourceType(PIDSourceType::kRate);
	rightEncoder->SetDistancePerPulse(1.0);

	goToDistanceState = 0;
	startingLeftDistance = 0;
	startingRightDistance = 0;
	targetLeft = 0;
	targetRight = 0;
	currentLeft = 0;
	currentRight = 0;
	currentLeftCentimeters = 0;
	currentRightCentimeters = 0;
	leftPercentThere = 0;
	rightPercentThere = 0;
	leftMotorMultiplier = 0;
	rightMotorMultiplier = 0;
	encoderClicksPerCentimeter = 30; // 7.2;
	GO_TO_DISTANCE_CORRECTION_SPEED = 5.0;
	powerOffset = 0;
	leftPower = 0;
	rightPower = 0;
}

void DriveTrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new DriveTrainC());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void DriveTrain::Periodic() {
    // Put code here to be run every loop

}

void DriveTrain::SetRightPower(double power) {
	rightMotor->Set(power);
}

void DriveTrain::SetLeftPower(double power) {
	leftMotor->Set(-power);
}

std::shared_ptr<frc::Encoder> DriveTrain::getLeftEncoder() {
	return leftEncoder;
}

std::shared_ptr<frc::Encoder> DriveTrain::getRightEncoder() {
	return rightEncoder;
}

bool DriveTrain::goToDistance(double rightCentimeters, double leftCentimeters, double power, int rampUpDistance, int rampDownDistance, double startingPower, double endingPower) {
	//Initial state
	if (goToDistanceState == 0) {
		goToDistanceState++;
		startingLeftDistance = leftEncoder->Get();
		startingRightDistance = rightEncoder->Get();
	}

	// --------------------------------------------------------------------------
	// ---------------------Get target and current distances---------------------
	// --------------------------------------------------------------------------
	// Get target distance in centimeters
	targetLeft = leftCentimeters * encoderClicksPerCentimeter;
	targetRight = rightCentimeters * encoderClicksPerCentimeter;

	// Get the current distance in centimeters
	currentLeft = std::abs((double)(leftEncoder->Get() - startingLeftDistance));
	currentRight = std::abs((double)(rightEncoder->Get() - startingRightDistance));
	currentLeftCentimeters = currentLeft / encoderClicksPerCentimeter;
	currentRightCentimeters = currentRight / encoderClicksPerCentimeter;
	// Find the percentage the left and right are to their target
	leftPercentThere = std::abs(currentLeft / targetLeft);
	rightPercentThere = std::abs(currentRight / targetRight);

	// Initially set the powers to their default values
	leftMotorMultiplier = 1;
	rightMotorMultiplier = 1;

	// --------------------------------------------------------------------------
	// ----------------Adjust powers if one side has gone farther----------------
	// --------------------------------------------------------------------------

	powerOffset = GO_TO_DISTANCE_CORRECTION_SPEED * std::abs(leftPercentThere - rightPercentThere);
	// Only start adjusting the powers once the motors have gone 2 percent
	// of the target distance, to avoid calculation errors
	if (currentRight >= (targetRight * 0.02) && (currentLeft >= (targetLeft * 0.02))) {
		// If the right is closer than the left, increase the left power and
		// decrease the right power
		if (rightPercentThere > (leftPercentThere + 0.001)) {
			leftMotorMultiplier *= 1 + powerOffset;
			rightMotorMultiplier *= 1 - powerOffset;
		}

		// If the left is closer than the right, increase the right power,
		// and decrease the left power
		if ((rightPercentThere + 0.001) < leftPercentThere) {
			leftMotorMultiplier *= 1 - powerOffset;
			rightMotorMultiplier *= 1 + powerOffset;
		}
	}

	// --------------------------------------------------------------------------
	// -----------------------Flip the powers if necessary-----------------------
	// --------------------------------------------------------------------------

	if ((rightEncoder->Get() - startingRightDistance) > targetRight) {
		rightMotorMultiplier *= -1;
	}

	if ((leftEncoder->Get() - startingLeftDistance) > targetLeft) {
		leftMotorMultiplier *= -1;
	}

	// --------------------------------------------------------------------------
	// -----------------------------Ramp Down Speeds-----------------------------
	// --------------------------------------------------------------------------

	double rampDownPercentage = 1;
	if (currentRightCentimeters < rampUpDistance) {
		rampDownPercentage = ((currentRightCentimeters / rampUpDistance) * (1 - startingPower)) + startingPower;
	} else if (currentRightCentimeters > std::abs(rightCentimeters) - rampDownDistance) {
		rampDownPercentage = (((std::abs(rightCentimeters) - currentRightCentimeters) / rampDownDistance) * (1 - endingPower)) + endingPower;
	}

	//Set motor speeds
	leftMotor->Set(-rightMotorMultiplier * power * rampDownPercentage);
	rightMotor->Set(leftMotorMultiplier * power * rampDownPercentage);

	//Check if we've made it
	if (rightPercentThere >= 1 && leftPercentThere >= 1) {
		leftMotor->Set(0);
		rightMotor->Set(0);
		goToDistanceState = 0;
		return true;
	}

	return false;
}
// Put methods for controlling this subsystem
// here. Call these from Commands.

