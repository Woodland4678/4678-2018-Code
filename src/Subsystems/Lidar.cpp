// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Lidar.h"
#include "SerialPort.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Lidar::Lidar() : frc::Subsystem("Lidar") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONSt
	printf("Lidar Initialization!\n");
	//SerialPort serport = frc::SerialPort(115200);
	serport = new frc::SerialPort(115200,frc::SerialPort::Port::kUSB,8,frc::SerialPort::Parity::kParity_None,frc::SerialPort::StopBits::kStopBits_One); // Set up serial port.
	serport->SetWriteBufferMode(frc::SerialPort::kFlushOnAccess);
	serport->SetFlowControl(frc::SerialPort::FlowControl::kFlowControl_None);
	serport->SetWriteBufferSize(128); // Don't need a lot of space for writing.
	serport->SetReadBufferSize(1024); // allow up to 1024 characters to be stored for reading.
	serport->Flush(); // Clear out any old data.
	samplecount = 0;
	cstate = 0;
	txseq = 0;
	prevangle = -1; // prevangle is not valid yet.
	tocnt = 0; // Time out counter, 10 seconds of readings and we stop everything.
	chcnt = 100;
	glob_lidar_ready = 0;

}

void Lidar::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Lidar::Periodic() {
    // Put code here to be run every loop
	int x,ch;

	if (txcmd != 0)
		{
		switch(txcmd)
			{
			case 1: // transmit data to get information packet from lidar
				//printf("Sending Info request string to serial port\n");
				serport->Write("\xA5\x5A\x14\x00\x00\x00\x04",7);
				//printf("Write(\\xA5\\x5A\\x14\\x00\\x00\\x00\\x04)\n");
				//printf("Get Info Requested A5 5A 14 00 00 00 04\n");
				txcmd = 0; // indicate this request has been sent.
				cstate=0;
				break;
			case 2: // stop - send to halt data being transmitted from lidar
				serport->Write("\xA5\x25",2);
				//printf("Stop A5 25 sent.\n");
				txcmd = 0;
				cstate = 0;
				break;
			case 3: // Reset - perform a reboot of the lidar system
				// Make sure we wait 2ms (1/500 sec) before sending another command.
				// should be no problem given that we'll only transmit at 50hz
				serport->Write("\xA5\x40",2);
				//printf("RESET A5 40");
				txcmd = 0;
				cstate = 0;
				break;
			case 4: // Express Scan.  There are other options but we're only implementing this one.
				serport->Write("\xA5\x82\x05\x00\x00\x00\x00\x00\x22",9);
				//printf("Express Scan Initiated\n");
				txcmd = 0;
				cstate = 0;
				break;
			case 5: // With USB interface board, we should be able to control motor speed 0 to 1023, default 660
				// Will need checksum calculation for this,  Start with 0 and ^= all bytes, including 0xA5 Sync
				//printf("Sending motor PWM command 0xF0\n");
				//serport->Write("\xA5\xF0\x02\x94\x02\xC1",6); // See if this will start the motor.
				//serport->Write("\xA5\xFF\x04\x00\x00\x00\x80\xDE",8); // Get flag to see if board supports PWM command.
				//serport->Write("\xA5\xFF",2);
				serport->Write("\xA5\xF0\x02",3);
				chksum = 0xA5^0xF0^0x02;
				serport->Write((char *)&pwmspeed,2);
				chksum ^= (pwmspeed & 0xFF);
				chksum ^= ((pwmspeed >> 8) & 0xFF); // calculate checksum.
				serport->Write((char *)&chksum,1);
				//printf("Write(\\A5\\F0\\02\\%02X\\%02X\\%02X)\n",pwmspeed&0xFF,pwmspeed>>8,chksum);
				txcmd = 0;
				break;
			case 6: // Get Health
				//printf("Sending Get Health 0x52\n",cstate);
				serport->Write("\xA5\x52",2);
				txcmd = 0;
				cstate = 0;
				break;
			case 7: // Send A5 50
				serport->Write("\xA5\x50");
				//printf("Write(\\xA5\\x50)");
				txcmd = 0;
				cstate = 0;
				break;
			case 8: // Send A5 59
				serport->Write("\xA5\x59");
				//printf("Write(\\xA5\\x59)");
				txcmd = 0;
				cstate = 0;
				break;
			}
		}
	loopcount = 0; // serport->Read() does not always read all available bytes.  Sometimes, we only get a few
	// loopcount will allow this routine to loop up to 25 times in order to try to get all the bytes
	bytes_available = serport->GetBytesReceived();
	tim1 = Timer::GetFPGATimestamp(); // See how much time this takes.
	while((loopcount < 25)&&(bytes_available > 0))
		{
		loopcount++;
		if (bytes_available > 1024)
			bytes_to_read = 1024;
		else
			bytes_to_read = bytes_available;
		if (bytes_to_read > 0)
			{
			 //printf("bytes_to_read=%d\n",bytes_to_read);
			 rdcnt = serport->Read(rxbuf,bytes_to_read);
			 for(x = 0;x<rdcnt;x++) // process each character in the serial port buffer.
				{
				ch = *(rxbuf+x); // get the character
				// printf("ch=%02x, cstate=%d, dcnt=%d\n",ch,cstate,dcnt);
				//if (cstate < 4)
				//if (chcnt < 16)
				//	{
				//	printf("%02X ",ch);
				//	chcnt++;
				//	}
				switch(cstate)
					{
					case 0: // expecting a packet start character
						if (ch == 0xA5)
							cstate++; // go to next state if we get a valid packet start character
						break;
					case 1: // Expecting char 2 of the response descriptor
						if (ch == 0x5A)
							{
							cstate++; // valid character, advance to next state
							bcnt = 0; // need to count 4 bytes in next case
							rdat = 0; // place result in rdat
							}
						else
							cstate=0; // not what we expected, back to state 0
						break;
					case 2: // 30 bits of response length.  Get all 32 and then split it.
						rdat |= (((unsigned int)(ch)) << (bcnt * 8)); // get data, LSB first.
						bcnt++;
						if (bcnt == 4)
							{
							sendmode = rdat >> 30; // get the 2 bits of send mode. 0=single response, 1=multiple response.
							nbytes = rdat & 0x3FFFFFFF; // strip to upper 2 bit from rdat and that's our data length.
							printf("\nExpecting %d data bytes\n",nbytes);
							if (nbytes < 100)
								cstate++;
							else
								cstate = 0; // error in length, back to state 0
							}
						break;
					case 3: // expecting data type
						dtype = ch; // 0x82 for Express Packet, 0x04 for response to get_info
						dcnt = 0; // prepare to count payload data bytes (counts to nbytes)
						cstate++;
						break;
					case 4: // expecting payload data of nbytes (can be up to 84 bytes for express scan mode)
						// will be considerably less when we get the info data block.
						if (dcnt < 128)
							payload[dcnt] = ch; // store the data as long as it doesn't exceed the buffer
						dcnt++;
						if (dcnt >= nbytes)
							{
							// payload is complete.  process the data
							//printf("Got a complete payload, dtype=%d bytes_to_read=%d, actually read=%d, available=%d\n",dtype,bytes_to_read,rdcnt,bytes_available);
							chcnt=0; // Show any characters we get on rs232 port, starting now
							if (dtype == 0x18) // This is info, get some of it
								{
								model = payload[0];
								firmware1 = payload[1];
								firmware2 = payload[2];
								hardware = payload[3];
								serial = (payload[4])+((unsigned int)payload[5]<<8)+((unsigned int)payload[5]<<16)+((unsigned int)payload[5]<<24);
								// we'll ignore the other serial numbers for now.
								printf("Lidar model:%d\n",model);
								printf("Lidar firmware %d.%d\n",firmware2,firmware1);
								printf("Lidar hardware %d\n",hardware);
								printf("Lidar serial number %d\n",serial);
								//txcmd = 6; // go check health
								cstate = 0;
								}
							else if (dtype == 0x06)
								{
								printf("Health = %02X\n",payload[0]);
								printf("Error Code=%02X%02X\n",payload[2],payload[1]);
								//txcmd = 5; // Try to start motor now.
								cstate = 0;
								}
							else if (dtype == 0x82) // This is the express scan data.  Time to sort out all the data bits and pieces
								{
								// First 4 bytes - sync1, 2, checksum, start angle, S indicator.
								synchbyte = (payload[0] & 0xF0) + ((payload[1] >> 4) & 0x0F); // This must be 0xA5
								if (synchbyte == 0xA5)
									{
									stangle = payload[2] + ((payload[3] & 0x7F) << 8); // actual start angle value.

									chksum = (payload[0] & 0x0F) + ((payload[1] << 4) & 0xF0); // 8 bit checksum
									//printf("stangle=%6.2f, chksum=%02X\n",(double)stangle/64.0,chksum);

									//int xx = 0;
									//for(acnt = 0;acnt < 0x82;acnt++)
									//	{
									//	printf("%02X ",payload[acnt]);
									//	xx ^= payload[acnt];
									//	}
									//printf("\nxx=%02X\nstangle=%d,prevangle=%d\n",xx & 0xFF,stangle,prevangle);

									tstamp = (int)(Timer::GetFPGATimestamp()*1000000); // get value in microseconds.
									// Don't worry about FPGATimestamp roll over.  It's 72 minutes
									// Possible mess up if running robot for a long time during program testing.

									// if we have a valid prevangle, update the cabdat[] from last express data set
									// with the correct angles and then add the cabdat[] to the full scan array and
									// then we can re-use cabdat[] to store data from this payload.
									if (prevangle != -1)
										{
										for(acnt=0;acnt<32;acnt++) // Do all 32 angles from last set of cabins
											{ // place actual angle values in previous cabin[] array.
											if (stangle >= prevangle)
												cabdat[acnt].angle = prevangle + (stangle - prevangle) * acnt / 32 + cabdat[acnt].angle;
											else
												cabdat[acnt].angle = prevangle + (23040 + stangle - prevangle) * acnt / 32 + cabdat[acnt].angle;
											if (cabdat[acnt].angle >= 23040)
												cabdat[acnt].angle -= 23040; // Correct for angles above 360 deg
											tmpdat[samplecount].dist = cabdat[acnt].dist;
											tmpdat[samplecount].angle = cabdat[acnt].angle;
											tmpdat[samplecount].tstamp = prevtstamp + (tstamp - prevtstamp) * acnt / 32; // record correct time-stamp values.
											if (samplecount < 1023)
												samplecount++;
											}
										}

									prevtstamp = tstamp;
									//printf("\nstangle=%d,%10.2f\n",stangle,(double)stangle/64.0);

									sss = payload[3] >> 7; // This is indicator of new scan (1 for first data set of a scan.)
									// if sss is 1, that means we have compiled a complete array of readings.
									// this is a good time to copy them to the array to be used by the main lidar
									// processing routines and then set the indicator to tell the forground
									// that data is ready.
									if ((sss == 1)||(stangle < prevangle)) // sss doesn't seem to work, just use cross over in angle value.
										{
										for(acnt = 0;acnt < samplecount;acnt++) // copy entire array.
											{
											lidat[acnt].angle = tmpdat[acnt].angle;
											lidat[acnt].dist = tmpdat[acnt].dist;
											lidat[acnt].tstamp = tmpdat[acnt].tstamp;
											//printf("%d,%d,%d\n",lidat[acnt].angle,lidat[acnt].dist,lidat[acnt].tstamp);
											}
										glob_lidar_ready = 1; // main processing routine can set this to 0 so
										// it can detect when the next valid lidar scan is ready for processing.
										glob_lidar_count = samplecount;
										samplecount = 0; // begin storing new data.
										skcnt=0; // Keep rebooter sleeping, data is coming in.
										}

									prevangle = stangle; // update prevangle to equal this angle for next data set.

									for(cabins = 0;cabins < 16;cabins++)
										{ // process the 16 cabins
										caboff = 4+cabins * 5; // offset to data start for this cabin
										dist1 = (payload[caboff] >> 2) + ((int)payload[caboff+1] << 8); // distance value
										// Documentation on angle data is not correct.  [caboff] may be msbit, may be lsbits.  Not sure.
										// going with the assumption that they're bits 4 and 5 and that [caboff + 4] is bits 0-3
										// Note that these are signed 5 bit values. 0b11111 = -1, 0x10000 = -16.
										// May need to have a look at the value to make sure we have the bits figured out correctly.
										//
										delta1 = ((payload[caboff+1] & 0x03) << 4) + (payload[caboff+4] & 0x0F); // 5 bits of angle delta
										if (delta1 >= 16)
											delta1-=32; // these are negative values 0b11111 (31) is actually -1.
										dist2 = (payload[caboff + 2] >> 2) + ((int)payload[caboff+3] << 8); // distance value
										delta2 = ((payload[caboff+3] & 0x03) << 4) + ((payload[caboff+4] & 0xF0) >> 4); // 5 bits of angle delta
										if (delta2 >= 16)
											delta2-=32;
										// have distance and delta angle.  These delta's are corrections to the
										// angle that would be calculated using direct interpolation between the stangle of this
										// set of 32 readings and the stangle of the next 32 readings. By doing (stangle[1] - stangle[2]) / 32
										// The trick is we need stangle[2] before we can calculate the angles for data of stangle[1]
										// with confident accurace.  Since angles between 270 and 90 won't matter to us, this is not a big deal.
										// When preparing the data set, it will be necessary to go back and update the previous 32
										// angles based on the stangle value of the new packet.
										cabdat[cabins<<1].dist = dist1;
										cabdat[cabins<<1].angle = delta1; // storing delta1 for now, will update with actual angle next reading.
										cabdat[(cabins<<1)+1].dist = dist2;
										cabdat[(cabins<<1)+1].angle = delta2;
										}
									dcnt = 0; // expect another 0x82 bytes, stay in this state.
									}
								else // Synch byte failed to be 0xA5.  Data is no longer aligned.
									{ // Stop the transfer and then re-initated it
									txcmd = 2; // This will send the scan stop request.
									txseq = 5; // Go to state 5 which will stop current scan and start another one.
									}
								}
							// cstate = 0; // Back to cstate 0 when we've received all the bytes we expected.
							} // if(dcnt >= nbytes)
						break;
					} // switch(cstate)
				} // (for x < bytes_to_read)
			} // if there were bytes to read.
		 // if ((bytes_to_read == 0)&&(txcmd == 0)) // If there's nothing to read, consider a sequence of commands to try to get scanner going.
		bytes_available = serport->GetBytesReceived();
		}
	if (txcmd == 0)
	 	 { // We really don't need to do a lot.  Just tell it to go, now that we have the speed thing figured out.
		 // We can modify this part to start the scan and monitor for problems.  If we stop getting data, this part of the code
		 // can reset the system and re-start.
		 //printf("txseq=%d\n",txseq);
		 switch(txseq)
			 {
			 case 0:// Start up the motor as the first thing we do.
				 if (glob_lidar_may_run != 0) // Wait for signal from main program loop to tell lidar to run.
				 	 {
					 txcmd = 5; // start up the motor
					 pwmspeed = 660;
					 // txcmd = 0;
					 skcnt = 0; // use this to delay for a 100 count (2 seconds) to allow lidar to spin up.
					 txseq++;
				 	 }
				 break;
			 case 1: // after the 2 second delay, start the scan and look for data.
				 skcnt++;
				 if (skcnt >= 100)
				 	 {
					 serport->Flush(); // Clear data from serial port.
					 cstate = 0; // begin at state 0 to obtain valid packets.
					 txcmd = 1;
					 txseq++;
				 	 }
				 break;
			 case 2: // Redundant motor start up.
				 txcmd = 5; // start up the motor
				 pwmspeed = 660;
				 txseq++;
				 break;
			 case 3:
				 txcmd = 4; // Begin scanning in express mode.
				 skcnt = 0; // next state will increase this.  It gets cleared when we receive valid scan data.
				 txseq++;
				 break;
			 case 4:
				 skcnt++;  // if this gets to 200, it's been 4 seconds since we got data. Restart the scanner.
				 if (skcnt >= 500)
					 txseq = 5; // restart.
				 if (glob_lidar_may_run == 0)
					 txseq = 7; // stop everything, lidar may shut down.
				 tocnt++;
				 if (tocnt >= 50)
					 glob_lidar_may_run = 0;
				 break;
			 case 5:
				 txcmd = 2; // Send a stop to stop the express scanning.
				 printf("\nLidar scan restarted!!\n");
				 txseq++;
				 break;
			 case 6:
				 txseq=3; // Back to txseq=3 which will start another express scan.
				 break;
			 case 7:
				 txcmd = 2;
				 txseq++;
				 break;
			 case 8:
				 pwmspeed = 0; // stop the motor.
				 txcmd = 5; // Motor speed to 0
				 txseq++;
				 break;
			 case 9:
				 if (glob_lidar_may_run == 0)
				 	 {
					 txseq = 0; // back to state 0 once lidar has been shut down.
					 // Intialize all the variables that will allow another lidar sequence to begin.
					 samplecount = 0;
					 cstate = 0;
					 txseq = 0;
					 prevangle = -1; // prevangle is not valid yet.
					 tocnt = 0; // Time out counter, 10 seconds of readings and we stop everything.
				 	 }
				 break;
		 	 }
	 	 }
	tim2 = Timer::GetFPGATimestamp(); // See how much time this takes.
	//printf("Time in Lidar::Periodic = %12.9f, loopcount=%d\n",tim2 - tim1,loopcount);
	} // proc_serial()

void Lidar::readLidar()
	{
	printf("Attempting to get scan data from Lidar\n");
	glob_lidar_may_run = 1;
	}

bool Lidar::readComplete()
	{
	return glob_lidar_may_run;
	}

void Lidar::convertToXY()
	{
	int j = 0;
	for(int i=0;i<glob_lidar_count;i++)
		{
		if(!lidat[i].dist)
			continue;
		double rad = M_PI * (lidat[i].angle) / 180;
		lidatXY[j].x = std::round(lidat[i].dist * std::sin(rad));
		lidatXY[j].y = std::round(lidat[i].dist * std::cos(rad));
		printf(" %i,%i",lidatXY[j].x,lidatXY[j].y);
		j++;
		}
	}
// Put methods for controlling this subsystem
// here. Call these from Commands.

