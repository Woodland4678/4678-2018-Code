// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctre/Phoenix.h"


#include "ManipulatorArm.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

ManipulatorArm::ManipulatorArm() : frc::Subsystem("ManipulatorArm") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    shoulder = RobotMap::manipulatorArmshoulder;
    elbow = RobotMap::manipulatorArmelbow;
    wrist = RobotMap::manipulatorArmwrist;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    shoulderNewSet = 0;

//    //Initialize the talons here:
//    double startPosition;
//    //Shoulder
//    shoulder->EnableCurrentLimit(true);
//    shoulder->ConfigPeakCurrentLimit(10, 0);
//	shoulder->Config_kP(0, 1, 0);
//	shoulder->Config_kI(0, 0, 0);
//	shoulder->Config_kD(0, 0, 0);
//	shoulder->ConfigAllowableClosedloopError(0, 20, 0);
//	shoulder->SetStatusFramePeriod(StatusFrame::Status_1_General_, 10, 0);
//    startPosition = static_cast<int>(getShoulderAngular()) % 4096;
//	if (startPosition < 0)
//		startPosition += 4096;
//	shoulder->GetSensorCollection().SetPulseWidthPosition(startPosition, 0);
//    //Elbow
//	elbow->EnableCurrentLimit(true);
//	elbow->ConfigPeakCurrentLimit(10, 0);
//	elbow->Config_kP(0, 1, 0);
//	elbow->Config_kI(0, 0, 0);
//	elbow->Config_kD(0, 0, 0);
//	elbow->ConfigAllowableClosedloopError(0, 20, 0);
//	elbow->SetStatusFramePeriod(StatusFrame::Status_1_General_, 10, 0);
//    startPosition = static_cast<int>(getElbowAngular()) % 4096;
//	if (startPosition < 0)
//		startPosition += 4096;
//	elbow->GetSensorCollection().SetPulseWidthPosition(startPosition, 0);
//    //Wrist
//	wrist->EnableCurrentLimit(true);
//	wrist->ConfigPeakCurrentLimit(10, 0);
//	wrist->Config_kP(0, 1, 0);
//	wrist->Config_kI(0, 0, 0);
//	wrist->Config_kD(0, 0, 0);
//	wrist->ConfigAllowableClosedloopError(0, 20, 0);
//	wrist->SetStatusFramePeriod(StatusFrame::Status_1_General_, 10, 0);
//    startPosition = static_cast<int>(getWristAngular()) % 4096;
//	if (startPosition < 0)
//		startPosition += 4096;
//	wrist->GetSensorCollection().SetPulseWidthPosition(startPosition, 0);
//
}

void ManipulatorArm::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void ManipulatorArm::Periodic() {
    // Put code here to be run every loop

}

void ManipulatorArm::initMovement(){
	origTimeStamp = frc::Timer::GetFPGATimestamp();
	shoulderStartPos = getShoulderAngular();
	elbowStartPos = getElbowAngular();
	wristStartPos = getWristAngular();
}

bool ManipulatorArm::pickUpCube() {
	double currTime = frc::Timer::GetFPGATimestamp() - origTimeStamp;

	//For how time you want the motion to take
	//	we will need to use the current position and calculate the amount of time from that

	//1000 is the target position
	shoulderGoToPosition(shoulderStartPos, 1000, currTime, 0.5);
	elbowGoToPosition(elbowStartPos, 1000, currTime, 0.5);
	wristGoToPosition(wristStartPos, 1000, currTime, 0.5);

	if(currTime > 0.5) //The 0.5 should be changed to the motion that takes the most time
		return true;
	return false;
}

//***Set PID values***
void ManipulatorArm::setShoulderPID(double p, double i, double d)
	{
	shoulder->Config_kP(0, p, 0);
	shoulder->Config_kI(0, i, 0);
	shoulder->Config_kD(0, d, 0);
	}

void ManipulatorArm::setElbowPID(double p, double i, double d)
	{
	elbow->Config_kP(0, p, 0);
	elbow->Config_kI(0, i, 0);
	elbow->Config_kD(0, d, 0);
	}

void ManipulatorArm::setWristPID(double p, double i, double d)
	{
	wrist->Config_kP(0, p, 0);
	wrist->Config_kI(0, i, 0);
	wrist->Config_kD(0, d, 0);
	}

//***Get Encoder Values From Talons***
double ManipulatorArm::getShoulderAngular()
	{
	return shoulder->GetSensorCollection().GetPulseWidthPosition();
	}

double ManipulatorArm::getWristAngular()
	{
	return wrist->GetSensorCollection().GetPulseWidthPosition();
	}

double ManipulatorArm::getElbowAngular()
	{
	return elbow->GetSensorCollection().GetPulseWidthPosition();
	}


//***Set Positions***
//These function send the talons a new setpoint
void ManipulatorArm::setShoulderPosition(double position)
	{
	shoulder->Set(ControlMode::Position, position);
	}

void ManipulatorArm::setElbowPosition(double position)
	{
	elbow->Set(ControlMode::Position, position);
	}

void ManipulatorArm::setWristPosition(double position)
	{
	wrist->Set(ControlMode::Position, position);
	}

//***Motion Control***
//These functions are used to get the arm to move to a given position in a certain amount of time
//This function must be called continuously at 50 times a second like the goToDistance code
//Parameters:
//	start - is the starting position of the joint
//		Note: start must remain constant throughout the movement!
//	position - The target position you want the joint to move to
//	current - is the amount of time that has past since this movement started
//		Before you start calling this function record the timestamp with this line of code: Timer::GetFPGATimestamp(); This timestamp must be constant throughout the movement
//		Now current is calculated like this: Timer::GetFPGATimestamp() - [recored timestamp from the beginning];
//	time - is the amount of time you want this motion to take in seconds

//Example say we are in TeleopPeriodic which is called 50 times a second
/*
switch(GoHere) {
	case 0:
		orgFPGA = Timer::GetFPGATimestamp(); //The timestamp at the beginning of the movement
		ShoulderStart = myShoulder->getAngular(); //Get the starting position
		GoHere++; //Go to the next state next time this function is called
		break;
	case 1:
		curTime = Timer::GetFPGATimestamp() - orgFPGA; //Calculate how much time has past
		myShoulder->goToPosition(ShoulderStart, -1000.0, curTime, 3); //Move the shoulder to -1000 in 3 seconds
		if (curTime > 3)
			GoHere++;
		break;
	case 2:
		//End of movement
		break;
}
*/
bool ManipulatorArm::shoulderGoToPosition(double start, double position, double current, double time)
	{
	shoulderNewSet = (position - start) * current / time + start;
	setShoulderPosition(shoulderNewSet);

	if (current > time)
		return true;
	return false;
	}

bool ManipulatorArm::elbowGoToPosition(double start, double position, double current, double time)
	{
	shoulderNewSet = (position - start) * current / time + start;
	setShoulderPosition(shoulderNewSet);

	if (current > time)
		return true;
	return false;
	}

bool ManipulatorArm::wristGoToPosition(double start, double position, double current, double time)
	{
	shoulderNewSet = (position - start) * current / time + start;
	setShoulderPosition(shoulderNewSet);

	if (current > time)
		return true;
	return false;
	}

//***Convert functions***
//To determine what values the variables need to be to convert the encoder and angles
//	Take the joint in question move it to a known angle like 0 degrees or 90 and record the encoder value for that angle
//		Do this for two angles
//	The M is the slope and B is the y intersection of the line

//Shoulder
double ManipulatorArm::convertShoulderToAngle(double encoder)
	{
	return (conShoulder_EtA_M *(encoder) + conShoulder_EtA_B); //EtA = Encoder to Angle
	}

double ManipulatorArm::convertShoulderToEncoder(double angle)
	{
	return (conShoulder_AtE_M *(angle) + conShoulder_AtE_B); //AtE = Angle to Encoder
	}

//Elbow
double ManipulatorArm::convertElbowToAngle(double encoder)
	{
	return (conElbow_EtA_M *(encoder) + conElbow_EtA_B); //EtA = Encoder to Angle
	}

double ManipulatorArm::convertElbowToEncoder(double angle)
	{
	return (conElbow_AtE_M *(angle) + conElbow_AtE_B); //AtE = Angle to Encoder
	}

//Wrist
double ManipulatorArm::convertWristToAngle(double encoder)
	{
	return (conWrist_EtA_M *(encoder) + conWrist_EtA_B); //EtA = Encoder to Angle
	}

double ManipulatorArm::convertWristToEncoder(double angle)
	{
	return (conWrist_AtE_M *(angle) + conWrist_AtE_B); //AtE = Angle to Encoder
	}
// Put methods for controlling this subsystem
// here. Call these from Commands.

