// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctre/Phoenix.h"


#include "ManipulatorArm.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

ManipulatorArm::ManipulatorArm() : frc::Subsystem("ManipulatorArm") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    shoulder = RobotMap::manipulatorArmshoulder;
    elbow = RobotMap::manipulatorArmelbow;
    wrist = RobotMap::manipulatorArmwrist;
    shoulderSlave = RobotMap::manipulatorArmshoulderSlave;
    elbowSlave = RobotMap::manipulatorArmelbowSlave;
    claw = RobotMap::manipulatorArmclaw;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    shoulderNewSet = 0;

    //Initialize the talons here:
    double startPosition;
    //Shoulder
    shoulderSlave->Follow(*shoulder);
    shoulder->EnableCurrentLimit(false);
    shoulder->ConfigVoltageCompSaturation(12, 0);
    shoulder->EnableVoltageCompensation(true);
	shoulder->Config_kP(0, 4, 0);
	shoulder->Config_kI(0, 0, 0);
	shoulder->Config_kD(0, 0, 0);
	shoulder->ConfigAllowableClosedloopError(0, 5, 0);
	shoulder->ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition, 0, 0);
	shoulder->SetStatusFramePeriod(StatusFrame::Status_1_General_, 10, 0);
    startPosition = (getShoulderAngular() % 4096);
	if (startPosition < 0)
		startPosition += 4096;
	shoulder->GetSensorCollection().SetPulseWidthPosition(startPosition, 0);
	shoulder->GetSensorCollection().SetQuadraturePosition(startPosition, 0);
    //Elbow
	elbowSlave->Follow(*elbow);
	elbow->SelectProfileSlot(0,0);
	//elbow->ConfigVelocityMeasurementPeriod(VelocityMeasPeriod::Period_1Ms, 0);
	elbow->ConfigVoltageCompSaturation(12, 0);
	elbow->EnableVoltageCompensation(false);
	elbow->EnableCurrentLimit(false);
	elbow->Config_kP(0, 2.5, 0);
	elbow->Config_kI(0, 0, 0);
	elbow->Config_kD(0, 0, 0);
	elbow->Config_IntegralZone(0, 10, 0);
	elbow->ConfigAllowableClosedloopError(0, 5, 0);
	elbow->ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Absolute, 0, 0);
	elbow->SetStatusFramePeriod(StatusFrame::Status_1_General_, 10, 0);
    startPosition = (getElbowAngular() % 4096);
	if (startPosition < 0)
		startPosition += 4096;
	elbow->SetSelectedSensorPosition(startPosition, 0, 0);
    //Wrist
	wrist->EnableCurrentLimit(false);
	wrist->ConfigVoltageCompSaturation(6, 0);
	wrist->EnableVoltageCompensation(true);
	wrist->Config_kP(0, 1, 0);
	wrist->Config_kI(0, 0, 0);
	wrist->Config_kD(0, 0, 0);
	wrist->ConfigAllowableClosedloopError(0, 5, 0);
	wrist->ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition, 0, 0);
	wrist->SetStatusFramePeriod(StatusFrame::Status_1_General_, 10, 0);
    startPosition = (getWristAngular() % 4096);
	if (startPosition < 0)
		startPosition += 4096;
	wrist->GetSensorCollection().SetPulseWidthPosition(startPosition, 0);

	posOffset = 4;
	multOffset = (12 + (posOffset - 4)) * 1000;
}

void ManipulatorArm::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void ManipulatorArm::Periodic() {
    // Put code here to be run every loop

}

void ManipulatorArm::initMovement(){
	origTimeStamp = frc::Timer::GetFPGATimestamp();
	shoulderStartPos = getShoulderAngular();
	elbowStartPos = getElbowAngular();
	wristStartPos = getWristAngular();
	shoulderMovement = false;
	elbowMovement = false;
	wristMovement = false;
}

bool ManipulatorArm::pickUpCube() {
	double currTime = frc::Timer::GetFPGATimestamp() - origTimeStamp;

	//For how time you want the motion to take
	//	we will need to use the current position and calculate the amount of time from that

	if (!shoulderMovement)
		shoulderMovement = shoulderGoToPosition(shoulderStartPos, -2227, currTime, 1.5); //-1155

	if (!elbowMovement)
		elbowMovement = elbowGoToPosition(elbowStartPos, 1910, currTime, 1.5);

	if (!wristMovement)
		wristMovement = wristGoToPosition(wristStartPos, 600, currTime, 1);

	if (shoulderMovement && elbowMovement && wristMovement)
		return true;
	return false;
}
bool ManipulatorArm::raiseCube() {
	double currTime = frc::Timer::GetFPGATimestamp() - origTimeStamp;

	//For how time you want the motion to take
	//	we will need to use the current position and calculate the amount of time from that

	if (!shoulderMovement)
		shoulderMovement = shoulderGoToPosition(shoulderStartPos, -698, currTime, 1.5);
	if (!elbowMovement)
		elbowMovement = elbowGoToPosition(elbowStartPos, -3057, currTime, 1.5);
	if (!wristMovement)
		wristMovement = wristGoToPosition(wristStartPos, -240, currTime, 1.5);

	if (shoulderMovement && elbowMovement && wristMovement)
		return true;
	return false;
}

//***Set PID values***
void ManipulatorArm::setShoulderPID(double p, double i, double d)
	{
	shoulder->Config_kP(0, p, 0);
	shoulder->Config_kI(0, i, 0);
	shoulder->Config_kD(0, d, 0);
	}

void ManipulatorArm::setElbowPID(double p, double i, double d, int zone)
	{
	elbow->Config_kP(0, p, 0);
	elbow->Config_kI(0, i, 0);
	elbow->Config_kD(0, d, 0);
	elbow->Config_IntegralZone(0, zone, 0);
	}

void ManipulatorArm::setWristPID(double p, double i, double d)
	{
	wrist->Config_kP(0, p, 0);
	wrist->Config_kI(0, i, 0);
	wrist->Config_kD(0, d, 0);
	}

//***Get Encoder Values From Talons***
int ManipulatorArm::getShoulderAngular()
	{
	frc::SmartDashboard::PutNumber("Shoulder Current", shoulder->GetOutputCurrent());
	frc::SmartDashboard::PutNumber("Shoulder Voltage", shoulder->GetMotorOutputVoltage());
	return shoulder->GetSensorCollection().GetPulseWidthPosition();
	}

int ManipulatorArm::getWristAngular()
	{
	return wrist->GetSensorCollection().GetPulseWidthPosition();
	}

int ManipulatorArm::getElbowAngular()
	{
	frc::SmartDashboard::PutNumber("Elbow Current", elbow->GetOutputCurrent());
	frc::SmartDashboard::PutNumber("Elbow Voltage", elbow->GetMotorOutputVoltage());
	return elbow->GetSelectedSensorPosition(0);
	}


//***Set Positions***
//These function send the talons a new setpoint
void ManipulatorArm::setShoulderPosition(double position)
	{
	shoulder->Set(ControlMode::Position, position);
	}

void ManipulatorArm::setElbowPosition(double position)
	{
	elbow->Set(ControlMode::Position, position);
	}

void ManipulatorArm::setWristPosition(double position)
	{
	wrist->Set(ControlMode::Position, position);
	}
void ManipulatorArm::squeeze() {
	claw->Set(frc::DoubleSolenoid::Value::kForward);
}
void ManipulatorArm::release() {
	claw->Set(frc::DoubleSolenoid::Value::kReverse);
}

//***Motion Control***
//These functions are used to get the arm to move to a given position in a certain amount of time
//This function must be called continuously at 50 times a second like the goToDistance code
//Parameters:
//	start - is the starting position of the joint
//		Note: start must remain constant throughout the movement!
//	position - The target position you want the joint to move to
//	current - is the amount of time that has past since this movement started
//		Before you start calling this function record the timestamp with this line of code: Timer::GetFPGATimestamp(); This timestamp must be constant throughout the movement
//		Now current is calculated like this: Timer::GetFPGATimestamp() - [recored timestamp from the beginning];
//	time - is the amount of time you want this motion to take in seconds

//Example say we are in TeleopPeriodic which is called 50 times a second
/*
switch(GoHere) {
	case 0:
		orgFPGA = Timer::GetFPGATimestamp(); //The timestamp at the beginning of the movement
		ShoulderStart = myShoulder->getAngular(); //Get the starting position
		GoHere++; //Go to the next state next time this function is called
		break;
	case 1:
		curTime = Timer::GetFPGATimestamp() - orgFPGA; //Calculate how much time has past
		myShoulder->goToPosition(ShoulderStart, -1000.0, curTime, 3); //Move the shoulder to -1000 in 3 seconds
		if (curTime > 3)
			GoHere++;
		break;
	case 2:
		//End of movement
		break;
}
*/
bool ManipulatorArm::shoulderGoToPosition(double start, double position, double current, double time)
	{
	//multOffset = (Sharpness + (offset - 4)) * 1000;
	double multiplier = (multOffset / (time*1000));
	//Calculate the new set point
	double NewSet = sigmod(position, start, multiplier, posOffset, current);

	//shoulderNewSet = (position - start) * current / time + start;
	setShoulderPosition(NewSet);

	//Return true if the elapse time is complete
	if (current > time)
		return true;
	return false;
	}

bool ManipulatorArm::elbowGoToPosition(double start, double position, double current, double time)
	{
	//multOffset = (Sharpness + (offset - 4)) * 1000;
	double multiplier = (multOffset / (time*1000));
	//Calculate the new set point
	double NewSet = sigmod(position, start, multiplier, posOffset, current);

	//shoulderNewSet = (position - start) * current / time + start;
	frc::SmartDashboard::PutNumber("Elbow Setpoint", NewSet);
	setElbowPosition(NewSet);

	//Return true if the elapse time is complete
	if (current > time)
		return true;
	return false;
	}

bool ManipulatorArm::wristGoToPosition(double start, double position, double current, double time)
	{
	//multOffset = (Sharpness + (offset - 4)) * 1000;
	double multiplier = (multOffset / (time*1000));
	//Calculate the new set point
	double NewSet = sigmod(position, start, multiplier, posOffset, current);

	//shoulderNewSet = (position - start) * current / time + start;
	setWristPosition(NewSet);

	//Return true if the elapse time is complete
	if (current > time)
		return true;
	return false;
	}

double ManipulatorArm::sigmod(double end, double start, double mult, double offset, double x)
	{
	return (((end-start)/(1+exp((-(mult*x))+offset)))+start);
	}

//***Convert functions***
//To determine what values the variables need to be to convert the encoder and angles
//	Take the joint in question move it to a known angle like 0 degrees or 90 and record the encoder value for that angle
//		Do this for two angles
//	The M is the slope and B is the y intersection of the line

//Shoulder
double ManipulatorArm::convertShoulderToAngle(double encoder)
	{
	return (conShoulder_EtA_M *(encoder) + conShoulder_EtA_B); //EtA = Encoder to Angle
	}

double ManipulatorArm::convertShoulderToEncoder(double angle)
	{
	return (conShoulder_AtE_M *(angle) + conShoulder_AtE_B); //AtE = Angle to Encoder
	}

//Elbow
double ManipulatorArm::convertElbowToAngle(double encoder)
	{
	return (conElbow_EtA_M *(encoder) + conElbow_EtA_B); //EtA = Encoder to Angle
	}

double ManipulatorArm::convertElbowToEncoder(double angle)
	{
	return (conElbow_AtE_M *(angle) + conElbow_AtE_B); //AtE = Angle to Encoder
	}

//Wrist
double ManipulatorArm::convertWristToAngle(double encoder)
	{
	return (conWrist_EtA_M *(encoder) + conWrist_EtA_B); //EtA = Encoder to Angle
	}

double ManipulatorArm::convertWristToEncoder(double angle)
	{
	return (conWrist_AtE_M *(angle) + conWrist_AtE_B); //AtE = Angle to Encoder
	}
// Put methods for controlling this subsystem
// here. Call these from Commands.

