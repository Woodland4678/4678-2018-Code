// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctre/Phoenix.h"

#include <iostream>
#include <fstream>
#include <ctime>
#include "ManipulatorArm.h"
#include "../Commands/moveArm.h"
#include "../RobotMap.h"

#define SHOULDER0EL			118
#define SHOULDER180EL		62

#define SHOULDERLOWLIMIT	47.0f
#define SHOULDERHIGHLIMIT	127.0f

#define ELBOWHIGHLIMIT		164.0f

#define WRISTLOWLIMIT		-120.0f
#define WRISTHIGHLIMIT		120.0f

#if FLIGHTBOT
#define SHOULDERLOWENCODER	-5070.0f//-5758.0f //4145 //-5070
#define	SHOULDERHIGENCODER	4018.0f//3386.0f	//5058 //4018

#define ELBOWLOWLIMIT		-156.2f
#define ELBOWLOWENCODER		-1125.0f
#define	ELBOWHIGENCODER		-13322.0f
#define ELBOWABSHOME		279.0f

#define WRISTLOWENCODER		7515.0f
#define	WRISTHIGENCODER		241.0f
#else
#define SHOULDERLOWENCODER	-6382.0f
#define	SHOULDERHIGENCODER	2743.0f

#define ELBOWLOWLIMIT		-159.2f
#define ELBOWLOWENCODER		-768.0f
#define	ELBOWHIGENCODER		-15928.0f
#define ELBOWABSHOME		220.0f

#define WRISTLOWENCODER		-1575.0f
#define	WRISTHIGENCODER		4553.0f
#endif
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

ManipulatorArm::ManipulatorArm() : frc::Subsystem("ManipulatorArm") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    shoulder = RobotMap::manipulatorArmshoulder;
    elbow = RobotMap::manipulatorArmelbow;
    wrist = RobotMap::manipulatorArmwrist;
    shoulderSlave = RobotMap::manipulatorArmshoulderSlave;
    elbowSlave = RobotMap::manipulatorArmelbowSlave;
    claw = RobotMap::manipulatorArmclaw;
    indicator = RobotMap::manipulatorArmindicator;
    cubeDetector = RobotMap::manipulatorArmcubeDetector;
    shoulderClimber = RobotMap::manipulatorArmshoulderClimber;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    //frc::SmartDashboard::PutNumber("Shoulder Degree", ShoulderDeg);
    //frc::SmartDashboard::PutNumber("Elbow Degree", elbowDeg);
}

bool ManipulatorArm::Init()
	{
	shoulderNewSet = 0;
	//Initialize the talons here:
	double startPosition;
	//Shoulder
	shoulderSlave->Follow(*shoulder);
	shoulder->EnableCurrentLimit(false);
	shoulder->ConfigVoltageCompSaturation(12, 0);
	shoulder->EnableVoltageCompensation(true);
	setShoulderPID(4,0,0,0,0);
	shoulder->ConfigAllowableClosedloopError(0, 5, 0);
	shoulder->ConfigSelectedFeedbackSensor(FeedbackDevice::QuadEncoder, 0, 0);
	shoulder->SetStatusFramePeriod(StatusFrame::Status_1_General_, 10, 0);
	
	int shAngCnt = 0;
	int pulse = 0;
	double enc = 0;
	do {
		startPosition = (shoulder->GetSensorCollection().GetPulseWidthPosition() % 4096);
		if (startPosition < 0)
			startPosition += 4096;
		shoulder->GetSensorCollection().SetPulseWidthPosition(startPosition, 0);
		shoulder->GetSensorCollection().SetQuadraturePosition(startPosition*0.776527742265, 0);

		pulse = shoulder->GetSensorCollection().GetPulseWidthPosition();
		enc = getShoulderAngular();
		if (std::abs(pulse - (enc/0.776527742265)) < 100)
			frc::SmartDashboard::PutBoolean("Shoulder Encoders", true);
		else
			frc::SmartDashboard::PutBoolean("Shoulder Encoders", false);

		shAngCnt++;
	}while((std::abs(pulse - (enc/0.776527742265)) > 100)&&(shAngCnt < 10));
	printf("Shoulder Encoders Took %i loop to be the same\n",shAngCnt);
	shoulderSeg.posX = 0;
	shoulderSeg.posY = 0;
	shoulderSeg.length = 37; //inches
	shoulderSeg.convSlope = (SHOULDERLOWLIMIT - SHOULDERHIGHLIMIT)/(SHOULDERLOWENCODER - SHOULDERHIGENCODER);//0.008594429939077;
	shoulderSeg.convIntercept = SHOULDERHIGHLIMIT - SHOULDERHIGENCODER * shoulderSeg.convSlope;//102.68635770235;
	shoulderSeg.setAbsAngle = 109;
	shoulderSeg.setRelAngle = 109;
	shoulderSeg.setEncValue = convertRelAngleToEncoder(&shoulderSeg, 109);
	shoulderSeg.setPosX = 0;
	shoulderSeg.setPosY = 0;

	shDegreePerSecond = 50;
	shMinTime = 1;
	updateShoulder();
	if(std::abs(shoulderSeg.absAngle - 109) < 15)
		frc::SmartDashboard::PutBoolean("Shoulder Angle", true);
	else
		frc::SmartDashboard::PutBoolean("Shoulder Angle", false);

	ShoulderDeg = shoulderSeg.absAngle;

	//Elbow
	elbowSlave->Follow(*elbow);
	elbow->SelectProfileSlot(0,0);
	elbow->ConfigVoltageCompSaturation(12, 0);
	elbow->EnableVoltageCompensation(false);
	elbow->EnableCurrentLimit(false);
	setElbowPID(3,0,0.2,0,0);
	elbow->ConfigAllowableClosedloopError(0, 5, 0);
	elbow->ConfigSelectedFeedbackSensor(FeedbackDevice::QuadEncoder, 0, 0);
	elbow->SetStatusFramePeriod(StatusFrame::Status_1_General_, 10, 0);
	elbow->SetSensorPhase(false);
	//elbow->SetInverted(true);
	startPosition = (elbow->GetSensorCollection().GetPulseWidthPosition() % 4096);;
	if (startPosition < 0)
		startPosition += 4096;
	elbow->GetSensorCollection().SetPulseWidthPosition(startPosition, 0);
	elbow->GetSensorCollection().SetQuadraturePosition(startPosition*(-4.03436), 0);

	elbowSeg.posX = 0;
	elbowSeg.posY = 37;
	elbowSeg.length = 40; //inches
	elbowSeg.convSlope = (ELBOWLOWLIMIT - ELBOWHIGHLIMIT)/(ELBOWLOWENCODER - ELBOWHIGENCODER);//-0.023020774;

	double pos = getElbowAngular();
	if(pos == 0)
		{
		pos = startPosition*(-4.03436);
		elbow->GetSensorCollection().SetQuadraturePosition(pos,0);
		}

	elbowSeg.convIntercept = ELBOWLOWLIMIT - pos*elbowSeg.convSlope;
#if FLIGHTBOT
	elbowSeg.setAbsAngle = -46;
	elbowSeg.setRelAngle = -155;
	elbowSeg.setEncValue = convertRelAngleToEncoder(&elbowSeg, -155);
#else
	elbowSeg.setAbsAngle = -49;
	elbowSeg.setRelAngle = -159;
	elbowSeg.setEncValue = convertRelAngleToEncoder(&elbowSeg, -159);
#endif
	elbowSeg.setPosX = shoulderSeg.posX + shoulderSeg.length * std::cos(shoulderSeg.setAbsAngle * (M_PI/180));
	elbowSeg.setPosY = shoulderSeg.posY + shoulderSeg.length * std::sin(shoulderSeg.setAbsAngle * (M_PI/180));


	elDegreePerSecond = 90;
	elMinTime = 1;
	updateElbow();
	
	if(std::abs(startPosition - (ELBOWABSHOME)) < 50)
		frc::SmartDashboard::PutBoolean("Elbow Angle", true);
	else
		frc::SmartDashboard::PutBoolean("Elbow Angle", false);
	elbowDeg = elbowSeg.absAngle;

	//Wrist
	wrist->EnableCurrentLimit(false);
	wrist->ConfigVoltageCompSaturation(8, 0);
	wrist->EnableVoltageCompensation(true);
	setWristPID(4,0,0,0,0);
	wrist->ConfigAllowableClosedloopError(0, 5, 0);
	wrist->ConfigSelectedFeedbackSensor(FeedbackDevice::QuadEncoder, 0, 0);
	wrist->SetStatusFramePeriod(StatusFrame::Status_1_General_, 10, 0);
	startPosition = (wrist->GetSensorCollection().GetPulseWidthPosition() % 4096);
	if (startPosition < 0)
		startPosition += 4096;
	wrist->GetSensorCollection().SetPulseWidthPosition(startPosition, 0);
	wrist->GetSensorCollection().SetQuadraturePosition(startPosition, 0);
	
	wristSeg.posX = 0;
	wristSeg.posY = 77;
	wristSeg.length = 6; //inches
	wristSeg.convSlope = (WRISTLOWLIMIT - WRISTHIGHLIMIT)/(WRISTLOWENCODER - WRISTHIGENCODER);//0.037453761
	wristSeg.convIntercept = WRISTHIGHLIMIT - WRISTHIGENCODER * wristSeg.convSlope;//-56.25369914;
	wristSeg.setAbsAngle = 0;
	wristSeg.setRelAngle = 50;
	wristSeg.setEncValue = convertRelAngleToEncoder(&wristSeg, 50);
	wristSeg.setPosX = elbowSeg.posX + elbowSeg.length * std::cos(elbowSeg.setAbsAngle * (M_PI/180));
	wristSeg.setPosY = elbowSeg.posY + elbowSeg.length * std::sin(elbowSeg.setAbsAngle * (M_PI/180));

	wrDegreePerSecond = 90; // 125; // 150; // was 90
	wrMinTime = 1; // 1.0; //  was 1.5
	updateWrist();
	
	if(std::abs(wristSeg.absAngle - 0) < 30)
		frc::SmartDashboard::PutBoolean("Wrist Angle", true);
	else
		frc::SmartDashboard::PutBoolean("Wrist Angle", false);

	posOffset = 4.25;
	multOffset = (9 + (posOffset - 4)) * 1000;
	
	indicator->Set(frc::Relay::Value::kOff);
	lightCounter = 0;
	lightCounter2 = 0;
	lightShowType = 0;

	//Positions:
	//Home Position
	positions[0][0] = 109;   //e:624     r:109
#if FLIGHTBOT
	positions[0][1] = -46 - positions[0][0];
#else
	positions[0][1] = -49 - positions[0][0];
#endif
	positions[0][2] = 0 - positions[0][1] - positions[0][0];     //e:2970    r:55

	//Scale front Max
	positions[1][0] = 87;    //e:-2634   r:87
	positions[1][1] = 75 - positions[1][0];    //e:-3673   r:-12
	positions[1][2] = 15 - positions[1][1] - positions[1][0];    //e:-99     r:-60

	//Scale front Min
	positions[2][0] = 122;   //e:1660    r:116
	positions[2][1] = 46 - positions[2][0];  //e:-1096   r:-71
	positions[2][2] = 14 - positions[2][1] - positions[2][0];    //e:687     r:-30

	//Scale back Max
	positions[3][0] = 95;    //e:-1745   r:93
	positions[3][1] = 108 - positions[3][0];   //e:-4714   r:12
	positions[3][2] = 165 - positions[3][1] - positions[3][0];   //e:3103    r:60

	//scale back min
	positions[4][0] = 57;    //e:-6042   r:64
	positions[4][1] = 142 - positions[4][0];   //e:-7272   r:71
	positions[4][2] = 165 - positions[4][1] - positions[4][0];   //e:2303    r:30

	//Pick up cube
	positions[5][0] = 97;//124;    //e:-1745   r:93
	positions[5][1] = -39 - positions[5][0];//-22;   //e:2478    r:-154
	positions[5][2] = -82 - positions[5][1] - positions[5][0];//-25;   //e:754     r:-28

	//Pick up cube middle
	positions[6][0] = 121;    //e:-2784   r:86
	positions[6][1] = -80 - positions[6][0];   //e:2134    r:-146
	positions[6][2] = -29 - positions[6][1] - positions[6][0];    //e:728     r:-29

	//Switch Front
	positions[7][0] = 113;   //e:2697    r:123
	positions[7][1] = -10 - positions[7][0];   //e:1614    r:-134
	positions[7][2] = 19 - positions[7][1] - positions[7][0];    //e:2302    r:30

	//Switch Back
	positions[8][0] = 68;    //e:-7080   r:123
	positions[8][1] = 191 - positions[8][0];   //e:-10001  r:134
	positions[8][2] = 158 - positions[8][1] - positions[8][0];   //e:728     r:-30

	//Grab climber
	positions[9][0] = 68;//56;//62;    //e:-5007   r:71
	positions[9][1] = 223 - positions[9][0];//212;//216;   //e:-10957  r:155
	positions[9][2] = 262 - positions[9][1] - positions[9][0];//265;//259;   //e:2649    r:43

	//Place climber
	positions[10][0] = 52;   //e:-859    r:99
	positions[10][1] = 118 - positions[10][0];   //e:-4154   r:0
	positions[10][2] = 143 - positions[10][1] - positions[10][0];  //e:3691    r:82

	positions[14][0] = 62;
	positions[14][1] = 135 - positions[14][0];
	positions[14][2] = 108 - positions[14][1] - positions[14][0];

	positions[16][0] = 52;
	positions[16][1] = 143 - positions[16][0];
	positions[16][2] = 111 - positions[16][1] - positions[16][0];

	positions[15][0] = 62;
	positions[15][1] = 142 - positions[15][0];
	positions[15][2] = 111 - positions[15][1] - positions[15][0];

	//Carry
	positions[11][0] = 124;  //e:3291    r:127
	positions[11][1] = -16 - positions[11][0];  //e:2479    r:-154 SDW -14 (was-17)
	positions[11][2] = 71 - positions[11][1] - positions[11][0];   //e:3851    r:88

	//Arm Position For when climbing
	positions[12][0] = 93;
	positions[12][1] = -24 - positions[12][0];
	positions[12][2] = -139 - positions[12][1] - positions[12][0];

	positions[13][0] = 72;
	positions[13][1] = -145;
	positions[13][2] = -120;

	currPos = 0;
	targetPos = 0;
	prevPos = 0;
	fineMovingGoing = 0;

	updateArm();
	bool good = true;
	pulse = shoulder->GetSensorCollection().GetPulseWidthPosition();
	enc = getShoulderAngular();
	if (std::abs(pulse - (enc/0.776527742265)) < 100)
		frc::SmartDashboard::PutBoolean("Shoulder Encoders", true);
	else
		{
		frc::SmartDashboard::PutBoolean("Shoulder Encoders", false);
		good = false;
		}
	if(std::abs(shoulderSeg.absAngle - 109) < 15)
		frc::SmartDashboard::PutBoolean("Shoulder Angle", true);
	else
		{
		frc::SmartDashboard::PutBoolean("Shoulder Angle", false);
		good = false;
		}

	if(std::abs(elbow->GetSensorCollection().GetPulseWidthPosition() - (ELBOWABSHOME)) < 50)
		frc::SmartDashboard::PutBoolean("Elbow Angle", true);
	else
		{
		frc::SmartDashboard::PutBoolean("Elbow Angle", false);
		good = false;
		}

	if(std::abs(wristSeg.absAngle - 0) < 30)
		frc::SmartDashboard::PutBoolean("Wrist Angle", true);
	else
		{
		frc::SmartDashboard::PutBoolean("Wrist Angle", false);
		good = false;
		}
	return good;
	}

void ManipulatorArm::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new moveArm(0));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void ManipulatorArm::Periodic() {
    // Put code here to be run every loop

	//Fine motion control
	if(Robot::oi->getoperate()->GetRawButton(5))
		{
		bool fMotionOk = false;
		if((targetPos >= 1)&&(targetPos <= 4))
			fMotionOk = true;
		else
			{
			if (targetPos > 8)
				fMotionOk = true;
			}
		double joyX = Robot::oi->getoperate()->GetRawAxis(2);
		double joyY = Robot::oi->getoperate()->GetRawAxis(3);
		double wristMove = Robot::oi->getoperate()->GetRawAxis(1);
		if(((std::abs(joyX-0) < 0.07)&&(std::abs(joyY-0) < 0.07))&&(std::abs(wristMove-0) < 0.05))
			fMotionOk = false;

		if(targetPos == 11) //just making sure :)
			fMotionOk = false;

		if(fMotionOk)
			{
			frc::SmartDashboard::PutBoolean("Fine Motion Override", true);
			fineMovingGoing = 1;

			if(std::abs(wristMove-0) > 0.05)
				Robot::manipulatorArm->moveWrist(wristMove);

			if((std::abs(joyX) > 0.07)||(std::abs(joyY) > 0.07))
				{
				joyValuesX[joyCount] = joyX;
				joyValuesY[joyCount] = joyY;
				joyCount++;
				if(joyCount == 4)
					{
					joyCount = 0;
					joyReached4 = true;
					}
				if(joyReached4)
					{
					//Filters, remove largest and lowest and average the remaining two
					double large = -3, small = 3;
					int larId = 0, smaId = 0;
					for(int i=0;i<4;i++)
						{
						double val = joyValuesX[i] + joyValuesY[i];
						if(val > large)
							{
							large = val;
							larId = i;
							continue;
							}
						if(val < small)
							{
							small = val;
							smaId = i;
							continue;
							}
						}
					//Average
					double sumX = 0;
					double sumY = 0;
					for(int i=0;i<4;i++)
						{
						if((i == larId)||(i == smaId))
							continue;
						sumX += joyValuesX[i];
						sumY += joyValuesY[i];
						}
					fineMovement(sumX / 2,-(sumY/2));
					}
				}
			}
		else
			{
			frc::SmartDashboard::PutBoolean("Fine Motion Override", false);
			fineMovingGoing = 0;
			}
		}
	else
		{
		//Move back and reset stuff
		}


	lightCounter++;
	switch(lightShowType)
		{
		case 0:
			indicator->Set(frc::Relay::Value::kOff);
			lightCounter2 = 0;
			lightCounter = 0;
			break;
		case 1: //Outside boundary
			if(lightCounter < 10)
				indicator->Set(frc::Relay::Value::kForward);
			if(lightCounter > 10)
				indicator->Set(frc::Relay::Value::kReverse);
			if(lightCounter > 20)
				{
				lightCounter2++;
				lightCounter = 0; //Start over again
				}
			if(lightCounter2 > 10)
				{
				lightShowType = 0;
				lightCounter2 = 0;
				}
			break;
		case 2: //Near Boundary
			indicator->Set(frc::Relay::Value::kForward);
			if(lightCounter > 50)
				lightShowType = 0;
			break;
		}
}

void ManipulatorArm::initMovement(){
	origTimeStamp = frc::Timer::GetFPGATimestamp();
	updateShoulder();
	updateElbow();
	updateWrist();
	
	shoulderStartPos = shoulderSeg.absAngle;
	elbowStartPos = elbowSeg.absAngle;
	wristStartPos = wristSeg.absAngle;
	shoulderStartPosRel = shoulderSeg.relAngle;
	elbowStartPosRel = elbowSeg.relAngle;
	wristStartPosRel = wristSeg.relAngle;

	if (logfile.is_open())
		{
		sprintf(buf,"B,%f,%f,%f,%f,%i,%i,%i\n",origTimeStamp,shoulderStartPos,elbowStartPos,wristStartPos,positions[targetPos][0],positions[targetPos][1],positions[targetPos][2]);
		logfile.write(buf,strlen(buf));
		}

	for(int i=0;i<4;i++)
		{
		pwrTable[0][i] = 0;
		pwrTable[1][i] = 0;
		pwrTable[2][i] = 0;
		}

	shoulderMovement = false;
	shoulderMovement2 = false;
	shoulderMovement3 = false;
	elbowMovement = false;
	wristMovement = false;
	moveCase = 0;
	shTarget1 = 0;
    shTarget2 = 0;
	shTime = 0;
	elTime = 0;
	wrTime = 0;
    shTime1 = 0;
    shTime2 = 0;
}

void ManipulatorArm::moveWrist(double joyValue)
	{
	double ang = wristSeg.setRelAngle + (joyValue * 1.0 );
	if(ang < -110)
		ang = -110;
	if (ang > 110)
		ang = 110;
	setWristRelAngle(ang);
	}

bool ManipulatorArm::fineMovement(double joyX, double joyY) {

	//Get current end point
	updateArm();
	double elbPosX = shoulderSeg.length * std::cos(positions[targetPos][0] * (M_PI/180));
	double elbPosY = shoulderSeg.length * std::sin(positions[targetPos][0] * (M_PI/180));

	double currX = elbPosX + elbowSeg.length * std::cos((positions[targetPos][1] + positions[targetPos][0]) * (M_PI/180));
	double currY = elbPosY + elbowSeg.length * std::sin((positions[targetPos][1]+ positions[targetPos][0]) * (M_PI/180));
	//Calculate Target Position
	double tarX = std::abs(currX); // Co-ords of target position.
	double tarY = std::abs(currY); // Allowable range is tarX +/- joyX * FINECONTROLBOXSIZE

	// New position can be determined by taking current position (wristSeg.setPosX and SetPosY)
	// and adding or subtracting a bit from them based on joystick position.
	// how much we add is in the range of 0.06 inches per 50th of a second to maybe 0.25 inches/execution cycle
	// abs of joystick position must be >0.07 so we should normalize this to 0 being at 0.07
	// if joyX > 0.07, add (joyX - 0.07)*0.3 or so.  if joyX < -0.07, add (joyX + 0.07)*0.3
	// same for joyY.  If result is beyond tarX +/- FINECONTROLBOXSIZE, set position to FINECONTROLBOXSIZE

	double newTarX = std::abs(wristSeg.setPosX); // by default, we go nowhere.
	double newTarY = std::abs(wristSeg.setPosY);

	if (joyX > 0.07)
		newTarX += (joyX-0.07)*0.3;
	else if (joyX < -0.07)
		newTarX += (joyX+0.07)*0.3;

	if (joyY > 0.07)
		newTarY += (joyY-0.07)*0.3;
	else if (joyY < -0.07)
		newTarY += (joyY+0.07)*0.3;

	if (newTarX > tarX + FINECONTROLBOXSIZE)
		newTarX = tarX + FINECONTROLBOXSIZE;
	if (newTarX < tarX - FINECONTROLBOXSIZE)
		newTarX = tarX - FINECONTROLBOXSIZE;

	if (newTarY > tarY + FINECONTROLBOXSIZE)
		newTarY = tarY + FINECONTROLBOXSIZE;
	if (newTarY < tarY - FINECONTROLBOXSIZE)
		newTarY = tarY - FINECONTROLBOXSIZE;

	//Check limits
	if(newTarX > 18)
		newTarX = 18;
	if(newTarX < -18)
		newTarX = -18;
	if(newTarY > 77)
		newTarY = 77;
	//if(tarY < 50)
	//	tarY = 50;
	if((newTarX < 1)&&(newTarY > 50))
		newTarX = 1;

	//printf("Targets: %f, %f\nPosition: %f, %f\nCircle: %f, %f\nNew Targets: %f, %f\n",tarX,tarY,wristSeg.posX,wristSeg.posY,currX,currY,newTarX,newTarY);

	//Inverse Kitematics
	//Elbow
	double casBrakets = ((std::pow(newTarX,2) + std::pow(newTarY,2)) - std::pow(37,2) - std::pow(40,2))/(-2*(37)*(40));
	//Check value incase it is too far
	if(casBrakets < -1)
		casBrakets = -1;
	if(casBrakets > 1)
		casBrakets = 1;
	double angElbow = M_PI - std::acos(casBrakets);
	//Shoulder
	double angShoulder = std::atan(newTarY / newTarX) - std::atan((40 * std::sin(-angElbow))/(37 + 40 * std::cos(-angElbow)));
	//Convert radians to degrees
	elbowDeg = (angElbow * 180) / M_PI;
	ShoulderDeg = (angShoulder * 180) / M_PI;

	//Check for negative
	if((currX) < 0)
		{
		ShoulderDeg = (90 - std::abs(ShoulderDeg)) + 90;
		elbowDeg *= -1;
		}

	if(ShoulderDeg > 127)
		ShoulderDeg = 127;
	if(ShoulderDeg < 48)
		ShoulderDeg = 48;
	if(elbowDeg > 164)
		elbowDeg = 164;
	if(elbowDeg < -164)
		elbowDeg = -164;

	elbowDeg -= ShoulderDeg;
	elbowDeg *= -1;

	//Lets just do some quick tests to make sure we aren't attempting to move
	//	too far too quickly
	if (std::abs(ShoulderDeg - shoulderSeg.absAngle) > 20)
		return false;
	if (std::abs(elbowDeg - elbowSeg.absAngle) > 20)
		return false;

	frc::SmartDashboard::PutNumber("Shoulder Degree", ShoulderDeg);
	frc::SmartDashboard::PutNumber("Elbow Degree", elbowDeg);
	printf("Degrees SH: %f , EL: %f\n\n",ShoulderDeg,elbowDeg);

	if (logfile.is_open())
		{
		sprintf(buf,"F,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f\n",joyX,joyY,tarX,tarY,wristSeg.posX,wristSeg.posY,newTarX,newTarY,currX,currY,casBrakets,angElbow,angShoulder,ShoulderDeg,elbowDeg,elbowDeg+ShoulderDeg);
		logfile.write(buf,strlen(buf));
		}

	setShoulderAbsAngle(ShoulderDeg);
	setElbowAbsAngle(elbowDeg);

	return true;
	}

bool ManipulatorArm::moveTo(int pos, double addShTime, double addElTime)
	{
	frc::SmartDashboard::PutNumber("Arm Case", moveCase);
	if(fineMovingGoing)
		return true;
	if(isClimber)
		return true;
	if((pos != targetPos) && (moveCase != 0))
		moveCase = 0;
	switch(moveCase)
		{
		case 0:
			targetPos = pos;
			if (logfile.is_open())
				{
				sprintf(buf,"M,%i,%i\n",targetPos,currPos);
				logfile.write(buf,strlen(buf));
				}
			initMovement();
			moveCase = 1;
			break;
		case 1:
			{
			//Pre calculations here, timing and shoulder movements
			//Timing
			wrTime = (std::abs(wristStartPosRel - positions[pos][2])) / wrDegreePerSecond;
			elTime = (std::abs(elbowStartPosRel - positions[pos][1])) / elDegreePerSecond;
			shTime = (std::abs(shoulderStartPosRel - positions[pos][0])) / shDegreePerSecond;

			if (logfile.is_open())
				{
				sprintf(buf,"Tb,%f,%f,%f\n",shTime,elTime,wrTime);
				logfile.write(buf,strlen(buf));
				}

			if(!Robot::isAuto)
				{
				shMinTime = 1.3;
				elMinTime = 1.3;
				//wrMinTime = 1;
				}

			if(shTime < shMinTime)
				shTime = shMinTime;
			if(elTime < elMinTime)
				elTime = elMinTime;
			if(wrTime < wrMinTime)
				wrTime = wrMinTime;
			
			//First time testing relative movements :)
			/*shTime = 5;
			elTime = 5;
			wrTime = 5;*/

			shTime += addShTime;
			elTime += addElTime;

			//Special cases
			if((currPos == 1)&&(targetPos == 11))
				elTime += 1.3;
			if((currPos == 11)&&(targetPos == 1))
				elTime += 0.4;
			if((currPos == 11)&&(targetPos == 4))
				{
				shTime += 0.2;
				elTime += 0.2;
				}
			if((currPos == 11)&&(targetPos == 3))
				{
				shTime += 0.2;
				elTime += 0.2;
				}
			if((currPos == 8)&&(targetPos == 2))
				elTime -= 0.2;
			//Extra shoulder positions
			//We have to determine how the arm needs to moves to stay within the 16"
			//Does the elbow move from one zone to another?
			//Current zone
			int currentZone = 1;
			int targetZone = 1;
			if(elbowStartPos <= 0)
				currentZone = 0;
			if(elbowStartPos >= 180)
				currentZone = 2;

			int absPos = positions[pos][1] + positions[pos][0];

			if(absPos <= 0)
				targetZone = 0;
			if(absPos >= 180)
				targetZone = 2;

			if((currentZone == 1)&&(targetZone == 1))
				{
				shTime += 0.2;
				}

			if(currentZone != targetZone)
				{
				bool twoZones = false;
				bool rTl = true;
				shoulderMovement2 = true;
				elTime += 0.25;
				if((std::abs(targetZone - currentZone)) > 1)
					{
					twoZones = true;
					//add a second to each?
					shTime += 0.7;
					elTime += 0.0;
					wrTime += 0.7;
					shoulderMovement2 = false;
					}
				if((std::abs(targetZone - currentZone)) == 1)
					{
					//shTime += 0.5;
					//elTime += 0.3;
					}
				if(currentZone != 1)
					{
					if(currentZone > targetZone)
					rTl = false;
					}
				else
					{
					if(currentZone < targetZone)
					rTl = false;
					}
				int getZero = 0;
				if(rTl)
					{
					float mult = (multOffset / (elTime*1000));
					//abs 90 first
					if(shoulderStartPos >= SHOULDER0EL)
						shTarget1 = shoulderStartPos;
					else
						{
						if(positions[pos][0] > SHOULDER0EL)
							shTarget1 = positions[pos][0];
						else
							shTarget1 = SHOULDER0EL;
						}
					getZero = 0 - shTarget1;
					printf("Rel Check = %i   0\n",getZero);
					shTime1 = invSigmod(positions[pos][1], elbowStartPosRel, mult,posOffset,getZero);
					shTime1 += 0;
					shTime +=0.2;
					//abs -90 second
					if(twoZones)
						{
						if(positions[pos][0] > SHOULDER180EL)
							{
							if(positions[pos][0] < SHOULDER180EL)
								shTarget2 = positions[pos][0];
							else
								shTarget2 = SHOULDER180EL;
							getZero = 180 - shTarget1;
							printf("Rel Check = %i   180\n",getZero);
							shTime2 = invSigmod(positions[pos][1], elbowStartPosRel, mult,posOffset,getZero);
							//shTime1 += 0.05;
							//Rounding
							shTime2 *= 100;
							shTime2 = (std::floor(shTime2)) / 100;
							//shTime2 += 0.2;
							}
						else
							shoulderMovement2 = true;
						}
					}
				else
					{
					float mult = (multOffset / (elTime*1000));
					//abs -90 first
					if(shoulderStartPos <= SHOULDER180EL)
						shTarget1 = shoulderStartPos;
					else
						{
						if(positions[pos][0] < SHOULDER180EL)
							shTarget1 = positions[pos][0];
						else
							shTarget1 = SHOULDER180EL;
						}
					getZero = 180 - shTarget1;
					printf("Rel Check = %i   180\n",getZero);
					shTime1 = invSigmod(positions[pos][1], elbowStartPosRel, mult,posOffset,getZero);
					shTime1 += 0;
					shTime += 0.2;
					//abs 90 second
					if(twoZones)
						{
						if(positions[pos][0] < SHOULDER0EL)
							{
							if(positions[pos][0] > SHOULDER0EL)
								shTarget2 = positions[pos][0];
							else
								shTarget2 = SHOULDER0EL;
							getZero = 0 - shTarget1;
							printf("Rel Check = %i   0\n",getZero);
							shTime2 = invSigmod(positions[pos][1], elbowStartPosRel, mult,posOffset,getZero);
							//shTime1 += 0.05;
							//Rounding
							shTime2 *= 100;
							shTime2 = (std::floor(shTime2)) / 100;
							//shTime2 += 0.2;
							}
						else
							shoulderMovement2 = true;
						}
					}
				}
			else
				{
				shoulderMovement2 = true;
				shoulderMovement3 = true;
				}
			//Special case:
			if((currPos == 11) && (targetPos == 5))
				{
				shTime = 1;
				elTime = 1;
				wrTime = 1;
				}
			if((currPos == 5) && (targetPos == 11))
				{
				shTime = 1;
				elTime = 1;
				wrTime = 0.5;
				}
			if((currPos == 4) && (targetPos == 11))
				shTime1 += 0.5;
			if(((currPos == 8) && (targetPos == 7))||((currPos == 7) && (targetPos == 8)))
				shTime2 += 0.2;
			if (logfile.is_open())
				{
				sprintf(buf,"Ta,%f,%f,%f,%f,%f\n",shTime,elTime,wrTime,shTime1,shTime2);
				logfile.write(buf,strlen(buf));

				sprintf(buf,"EM,%f,%f\n",shTarget1,shTarget2);
				logfile.write(buf,strlen(buf));
				}
			//shoulderMovement = true;
			//elbowMovement = true;
			moveCase += 1;
			}
			break;
		case 2:
			{
			updateArm();
			double currTime = frc::Timer::GetFPGATimestamp() - origTimeStamp;

			if (logfile.is_open())
				{
				sprintf(buf,"T,%f\n",currTime);
				logfile.write(buf,strlen(buf));
				}

			//frc::SmartDashboard::PutNumber("Shoulder Time", shTime);
			//frc::SmartDashboard::PutNumber("Elbow Time", elTime);
			//frc::SmartDashboard::PutNumber("Wrist Time", wrTime);

			//frc::SmartDashboard::PutNumber("Current Time", currTime);

			//Extra movements
			if((shTarget1 != 0) && (!shoulderMovement3))
				shoulderMovement3 = shoulderGoToPosition(shoulderStartPosRel,shTarget1,currTime,shTime1,true);//Move shoulder back
			if ((shTarget2 != 0) && shoulderMovement3 && (!shoulderMovement2))
				shoulderMovement2 = shoulderGoToPosition(shTarget1,shTarget2,currTime-shTime1,shTime2,true); //Move shoulder forward to 67 in what?
			
			//Normal movements
			if (shoulderMovement3 && shoulderMovement2 && (!shoulderMovement))
				{
				if (shTarget1 != 0)
					shoulderStartPosRel = shTarget1;
				if (shTarget2 != 0)
					shoulderStartPosRel = shTarget2;
				shoulderMovement = shoulderGoToPosition(shoulderStartPosRel,positions[pos][0],currTime-(shTime1+shTime2),shTime,true);
				}
			if (!elbowMovement)
				elbowMovement = elbowGoToPosition(elbowStartPosRel,positions[pos][1],currTime,elTime,true);
			if (!wristMovement)
				wristMovement = wristGoToPosition(wristStartPosRel,positions[pos][2],currTime,wrTime,true);
			
			//frc::SmartDashboard::PutNumber("Shoulder Complete", shoulderMovement);
			//frc::SmartDashboard::PutNumber("Elbow Complete", elbowMovement);
			//frc::SmartDashboard::PutNumber("Wrist Complete", wristMovement);

			//Movement Check
			if(shoulderMovement && elbowMovement && wristMovement)
				{
				moveCase++;
				prevPos = currPos;
				currPos = pos;
				moveCase = 3;
				if (logfile.is_open())
					{
					sprintf(buf,"C\n");
					logfile.write(buf,strlen(buf));
					}
				if(pos == 9)
					{
					pickupCount = 0;
					pickupCount2 = 0;
					moveCase = 5;
					}
				}
			}
			break;
		case 3:
			moveCase = 0;
			//Print out the power stuff
			frc::SmartDashboard::PutNumber("Sh 0 - 25", pwrTable[0][0]);
			frc::SmartDashboard::PutNumber("Sh 25 - 50", pwrTable[0][1]);
			frc::SmartDashboard::PutNumber("Sh 50 - 90", pwrTable[0][2]);
			frc::SmartDashboard::PutNumber("Sh 90+", pwrTable[0][3]);

			frc::SmartDashboard::PutNumber("El 0 - 25", pwrTable[1][0]);
			frc::SmartDashboard::PutNumber("El 25 - 50", pwrTable[1][1]);
			frc::SmartDashboard::PutNumber("El 50 - 90", pwrTable[1][2]);
			frc::SmartDashboard::PutNumber("El 90+", pwrTable[1][3]);

			frc::SmartDashboard::PutNumber("Wr 0 - 25", pwrTable[2][0]);
			frc::SmartDashboard::PutNumber("Wr 25 - 50", pwrTable[2][1]);
			frc::SmartDashboard::PutNumber("Wr 50 - 90", pwrTable[2][2]);
			frc::SmartDashboard::PutNumber("Wr 90+", pwrTable[2][3]);

			return true;
			break;
		case 4:
			{
			//If we end up here somehow
			moveCase = 0;
			return true;
			break;
			}
		case 5:
			pickupCount++;
			if(pickupCount > 5)
				squeeze();
			//I have to assume that we have it
			//Move straight up and then turn wrist
			if(pickupCount > 15)//Wait a moment to ensure the claw clamped down
				{
				pickupCount2++;
				setShoulderAbsAngle(positions[9][0] - (pickupCount2 * 0.1));
				setElbowRelAngle(positions[9][1] - (pickupCount2 * 0.1));
				if(pickupCount2 > 5)
					{
					setWristRelAngle(positions[9][2] - 90);
					moveCase = 3;
					}
				}
			break;
		}
	return false;
	}

bool ManipulatorArm::moveToRelative(int pos, double addShTime, double addElTime)
	{
	if(fineMovingGoing)
		return true;
	if(isClimber)
		return true;
	if((pos != targetPos) && (moveCase2 != 0))
		moveCase2 = 0;
	switch(moveCase2)
		{
		case 0:
			targetPos = pos;
			if (logfile.is_open())
				{
				sprintf(buf,"M,%i,%i\n",targetPos,currPos);
				logfile.write(buf,strlen(buf));
				}
			initMovement();
			moveCase2 = 1;
			break;
		case 1:
			//Timing
			wrTime = (std::abs(wristStartPosRel - positions[pos][2])) / wrDegreePerSecond;
			elTime = (std::abs(elbowStartPosRel - positions[pos][1])) / elDegreePerSecond;
			shTime = (std::abs(shoulderStartPosRel - positions[pos][0])) / shDegreePerSecond;

			if (logfile.is_open())
				{
				sprintf(buf,"Tb,%f,%f,%f\n",shTime,elTime,wrTime);
				logfile.write(buf,strlen(buf));
				}

			if(shTime < shMinTime)
				shTime = shMinTime;
			if(elTime < elMinTime)
				elTime = elMinTime;
			if(wrTime < wrMinTime)
				wrTime = wrMinTime;

			shTime += addShTime;
			elTime += addElTime;

			//Here we not bother checking for the 16" stuff
			moveCase2 = 2;
			break;
		case 2:
			{
			updateArm();
			double currTime = frc::Timer::GetFPGATimestamp() - origTimeStamp;

			if (logfile.is_open())
				{
				sprintf(buf,"T,%f\n",currTime);
				logfile.write(buf,strlen(buf));
				}
			//Normal movements
			if (!shoulderMovement)
				shoulderMovement = shoulderGoToPosition(shoulderStartPosRel,positions[pos][0],currTime,shTime,true);
			if (!elbowMovement)
				elbowMovement = elbowGoToPosition(elbowStartPosRel,positions[pos][1],currTime,elTime,true);
			if (!wristMovement)
				wristMovement = wristGoToPosition(wristStartPosRel,positions[pos][2],currTime,wrTime,true);

			//Movement Check
			if(shoulderMovement && elbowMovement && wristMovement)
				{
				prevPos = currPos;
				currPos = pos;
				moveCase2 = 3;
				if (logfile.is_open())
					{
					sprintf(buf,"C\n");
					logfile.write(buf,strlen(buf));
					}
				}
			break;
			}
		case 3:
			moveCase2 = 0;
			return true;
			break;
		}
	return false;
	}

bool ManipulatorArm::pickUpCube()
	{
	static int counter1 = 0, counter2 = 0, shStart = 0, subtractAng = 8;
	static double orgTime = 0;
	//The purpose of this function is to move the claw
	//	down to grab the cube
	//NOTE: This function assumes that the arm is in pickup position.
	switch(pickUpCase)
		{
		case 0:
			counter1 = 0;
			counter2 = 0;
			shStart = shoulderSeg.absAngle;
			if (Robot::intake->checkPosition() == 1) {
				Robot::intake->setLifterPosition(4000+6000);
			}
			pickUpCase = 1;
			if(checkForCube())
				subtractAng = 4;
			else
				subtractAng = 8;
			orgTime = frc::Timer::GetFPGATimestamp();
			break;
		case 1:
			{
			double currTime = frc::Timer::GetFPGATimestamp() - orgTime;
			//Move shoulder down
			double newAngle = (((double)shStart - (double)subtractAng) - (double)shStart) * currTime / (0.2) + (double)shStart;
			setShoulderAbsAngle(newAngle);
			//setShoulderAbsAngle(shStart - (counter1*1.0));
			//setShoulderAbsAngle(shStart - 10);
			//if(checkForCube())
			//	counter2++;
			/*if(checkForCube())//5
				{
				counter1 = 0;
				pickUpCase = 2;
				}*/
			if(currTime > 0.2) //10
				{
				counter1 = 0;
				pickUpCase = 2;
				}
			break;
			}
		case 2:
			counter1++;
			if(counter1 > 5) //10
				pickUpCase = 3;
			break;
		case 3:
			squeeze();
			counter1 = 0;
			pickUpCase = 4;
			break;
		case 4:
			counter1++;
			if(counter1 > 10)//15
				{
				counter1 = 0;
				Robot::intake->release();
				pickUpCase = 5;
				}
			break;
		case 5:
			counter1++;
			if(counter1 > 2)//15
				{
				counter1 = 0;
				moveCase = 0;
				pickUpCase = 6;
				}
			break;
		case 6:
			//Move back to position 11
			if(moveTo(11))
				pickUpCase = 7;
			break;
		case 7:
			pickUpCase = 0;
			return true;
			break;
		}
	return false;
	}

bool ManipulatorArm::pickUpCubeAuto()
	{
	static int counter1 = 0, counter2 = 0, shStart = 0;
	//The purpose of this function is to move the claw
	//	down to grab the cube
	//NOTE: This function assumes that the arm is in pickup position.
	switch(pickUpCase)
		{
		case 0:
			counter1 = 0;
			counter2 = 0;
			shStart = shoulderSeg.absAngle;
			pickUpCase = 1;
			break;
		case 1:
			counter1++;
			//Move shoulder down
			setShoulderAbsAngle(shStart - 8);
			//if(checkForCube())
			//	counter2++;
			if(checkForCube())//5
				{
				counter1 = 0;
				pickUpCase = 2;
				}
			/*if(counter1 > 5) //10
				{
				counter1 = 0;
				pickUpCase = 2;
				}*/
			break;
		case 2:
			counter1++;
			if(counter1 > 5) //10
				pickUpCase = 3;
			break;
		case 3:
			squeeze();
			counter1 = 0;
			pickUpCase = 4;
			break;
		case 4:
			counter1++;
			if(counter1 > 12)//15
				{
				counter1 = 0;
				Robot::intake->release();
				pickUpCase = 5;
				}
			break;
		case 5:
			counter1++;
			if(counter1 > 5)//15
				{
				counter1 = 0;
				moveCase = 0;
				pickUpCase = 6;
				}
			break;
		case 6:
			//Move back to position 11
			if(moveTo(11))
				pickUpCase = 7;
			break;
		case 7:
			pickUpCase = 0;
			return true;
			break;
		}
	return false;
	}



bool ManipulatorArm::calibrate()
	{
	static int mainCase = 0, shCase = 0, elCase = 0, wrCase = 0, count = 0,wrCount = 0;
	switch(mainCase)
		{
		case 0:
			shCase = 0;
			elCase = 0;
			wrCase = 0;
			count = 0;
			mainCase = 1;
			break;
		case 1:
			switch(shCase)
				{
				case 0:
					//Set shoulder speed
					count++;
					setShoulderSpeed(0.2);
					if((shoulder->GetSensorCollection().GetQuadratureVelocity() > 0.2)||(count > 20))
						shCase = 1;
					break;
				case 1:
					//Check speed
					if (shoulder->GetSensorCollection().GetQuadratureVelocity() < 0.1)
						shCase = 2;
					break;
				case 2:
					setShoulderSpeed(0);
					if(std::abs(getShoulderAngular() - (SHOULDERHIGENCODER+400)) > 300) //Check if there may have been a chain jump
						shChainJump = true;
					frc::SmartDashboard::PutBoolean("Shoulder Skip", shChainJump);
					shoulder->SetSelectedSensorPosition(SHOULDERHIGENCODER+400, 0, 0);
					//shoulderSeg.convIntercept = 127 - getShoulderAngular() * shoulderSeg.convSlope;
					shCase = 3;
					mainCase = 2;
					count = 0;
					break;
				}
			break;
		case 2:
			count++;
			switch(elCase)
				{
				case 0:
					{
					double elAbsEncoder = elbow->GetSensorCollection().GetPulseWidthPosition();
					//Check for chain skip
					double quadExpected = elAbsEncoder * 4.03436;
					elbow->GetSensorCollection().SetQuadraturePosition(-quadExpected, 0);
					elbowSeg.encValue = getElbowAngular();
					elCase = 1;
					break;
					}
				case 1:
					elCase = 4;
					break;
				}
			switch(wrCase)
				{
				case 0:
					//Set wrist speed
#if FLIGHTBOT
					wrist->Set(ControlMode::PercentOutput, -0.2);
#else
					wrist->Set(ControlMode::PercentOutput, 0.2);
#endif
					if((wrist->GetSensorCollection().GetQuadratureVelocity() > 0.1)||(count > 20))
					{
						wrCount = 0;
						wrCase = 1;
					}

					break;
				case 1:
					//Check speed
					wrCount++;
					if (wrist->GetSensorCollection().GetQuadratureVelocity() < 0.05)
					{
						if(wrCount > 32)
							wrCase = 2;
					}
					else
						wrCount = 0;
					break;
				case 2:
					wrist->Set(ControlMode::PercentOutput, 0);
					wrist->SetSelectedSensorPosition(WRISTHIGENCODER-100, 0, 0);
					wrCase = 3;
					break;
				}
			if((elCase == 4)&&(wrCase == 3))
				{
				mainCase = 0;
				return true;
				}
			break;
		}
	return false;
	}

//***Set PID values***
void ManipulatorArm::setShoulderPID(double p, double i, double d, int zone, double f)
	{
	shoulder->Config_kF(0, f, 0);
	shoulder->Config_kP(0, p, 0);
	shoulder->Config_kI(0, i, 0);
	shoulder->Config_kD(0, d, 0);
	shoulder->Config_IntegralZone(0, zone, 0);
	}

void ManipulatorArm::setElbowPID(double p, double i, double d, int zone, double f)
	{
	elbow->Config_kF(0, f, 0);
	elbow->Config_kP(0, p, 0);
	elbow->Config_kI(0, i, 0);
	elbow->Config_kD(0, d, 0);
	elbow->Config_IntegralZone(0, zone, 0);
	}

void ManipulatorArm::setWristPID(double p, double i, double d, int zone, double f)
	{
	wrist->Config_kF(0, f, 0);
	wrist->Config_kP(0, p, 0);
	wrist->Config_kI(0, i, 0);
	wrist->Config_kD(0, d, 0);
	wrist->Config_IntegralZone(0, zone, 0);
	}

//***Get Encoder Values From Talons***
int ManipulatorArm::getShoulderAngular()
	{
	return shoulder->GetSelectedSensorPosition(0);
	}

int ManipulatorArm::getWristAngular()
	{
	return wrist->GetSensorCollection().GetPulseWidthPosition();
	}

int ManipulatorArm::getElbowAngular()
	{
	//frc::SmartDashboard::PutNumber("Elbow Current", elbow->GetOutputCurrent());
	//frc::SmartDashboard::PutNumber("Elbow Voltage", elbow->GetMotorOutputVoltage());
	return elbow->GetSelectedSensorPosition(0);
	}


//***Set Positions***
void ManipulatorArm::setElbowSpeed(double speed)
	{
	elbow->Set(ControlMode::PercentOutput, speed);
	}
void ManipulatorArm::setShoulderSpeed(double speed)
	{
	shoulder->Set(ControlMode::PercentOutput, speed);
	}

//These functions send the talons a new setpoint
void ManipulatorArm::setShoulderRelAngle(double angle)
	{
	setShoulderAbsAngle(angle);
	}
void ManipulatorArm::setElbowRelAngle(double angle)
	{
	double pos = convertRelAngleToEncoder(&elbowSeg, angle);
	elbowSeg.setAbsAngle = angle + shoulderSeg.setAbsAngle;
	elbowSeg.setRelAngle = angle;
	elbowSeg.setEncValue = pos;
	wristSeg.setPosX = elbowSeg.posX + elbowSeg.length * std::cos(elbowSeg.setAbsAngle * (M_PI/180));
	wristSeg.setPosY = elbowSeg.posY + elbowSeg.length * std::sin(elbowSeg.setAbsAngle * (M_PI/180));
	if (logfile.is_open())
		{
		sprintf(buf,"E,%f,%f,%f,%f,%i,%f\n",elbowSeg.absAngle,elbowSeg.setAbsAngle,elbowSeg.relAngle, angle, getElbowAngular(), pos);
		logfile.write(buf,strlen(buf));
		}
	//printf("%f , %f , %f\n",elbowSeg.setAbsAngle,elbowSeg.setRelAngle,elbowSeg.setEncValue);
	elbow->Set(ControlMode::Position, pos);
	}
void ManipulatorArm::setWristRelAngle(double angle)
	{
	double pos = convertRelAngleToEncoder(&wristSeg, angle);
	wristSeg.setAbsAngle = angle + elbowSeg.setRelAngle + shoulderSeg.setAbsAngle;
	wristSeg.setRelAngle = angle;
	wristSeg.setEncValue = pos;
	if (logfile.is_open())
		{
		sprintf(buf,"W,%f,%f,%f,%f,%i,%f\n",wristSeg.absAngle,wristSeg.setAbsAngle,wristSeg.relAngle, angle, getWristAngular(), pos);
		logfile.write(buf,strlen(buf));
		}

	wrist->Set(ControlMode::Position, pos);
	}

void ManipulatorArm::setShoulderAbsAngle(double angle)
	{
	double pos = convertRelAngleToEncoder(&shoulderSeg, angle);
	shoulderSeg.setAbsAngle = angle;
	shoulderSeg.setEncValue = pos;
	elbowSeg.setPosX = shoulderSeg.posX + shoulderSeg.length * std::cos(shoulderSeg.setAbsAngle * (M_PI/180));
	elbowSeg.setPosY = shoulderSeg.posY + shoulderSeg.length * std::sin(shoulderSeg.setAbsAngle * (M_PI/180));
	if (logfile.is_open())
		{
		sprintf(buf,"S,%f,%f,%i,%f\n",shoulderSeg.absAngle, angle, getShoulderAngular(), pos);
		logfile.write(buf,strlen(buf));
		}

	shoulder->Set(ControlMode::Position, pos);
	}
void ManipulatorArm::setElbowAbsAngle(double angle)
	{
	//Convert to relative
	double relAng = angle - shoulderSeg.setAbsAngle;
	double pos = convertRelAngleToEncoder(&elbowSeg, relAng);
	elbowSeg.setAbsAngle = angle;
	elbowSeg.setRelAngle = relAng;
	elbowSeg.setEncValue = pos;
	wristSeg.setPosX = elbowSeg.setPosX + elbowSeg.length * std::cos(elbowSeg.setAbsAngle * (M_PI/180));
	wristSeg.setPosY = elbowSeg.setPosY + elbowSeg.length * std::sin(elbowSeg.setAbsAngle * (M_PI/180));
	if (logfile.is_open())
		{
		sprintf(buf,"E,%f,%f,%f,%f,%i,%f\n",elbowSeg.absAngle,angle,elbowSeg.relAngle, relAng, getElbowAngular(), pos);
		logfile.write(buf,strlen(buf));
		}
	//printf("%f , %f , %f\n",elbowSeg.setAbsAngle,elbowSeg.setRelAngle,elbowSeg.setEncValue);
	elbow->Set(ControlMode::Position, pos);
	}
void ManipulatorArm::setWristAbsAngle(double angle)
	{
	//Convert to relative
	double relAng = angle - elbowSeg.setRelAngle - shoulderSeg.setAbsAngle;
	double pos = convertRelAngleToEncoder(&wristSeg, relAng);
	wristSeg.setAbsAngle = angle;
	wristSeg.setRelAngle = relAng;
	wristSeg.setEncValue = pos;
	if (logfile.is_open())
		{
		sprintf(buf,"W,%f,%f,%f,%f,%i,%f\n",wristSeg.absAngle,angle,wristSeg.relAngle, relAng, getWristAngular(), pos);
		logfile.write(buf,strlen(buf));
		}

	wrist->Set(ControlMode::Position, pos);
	}

void ManipulatorArm::setShoulderPosition(double position)
	{
	shoulder->Set(ControlMode::Position, position);
	}

void ManipulatorArm::setElbowPosition(double position)
	{
	//elbow->Set(ControlMode::Position, position);
	}

void ManipulatorArm::setWristPosition(double position)
	{
	//wrist->Set(ControlMode::Position, position);
	}
void ManipulatorArm::squeeze() {
	claw->Set(frc::DoubleSolenoid::Value::kForward);
}
void ManipulatorArm::release() {
	claw->Set(frc::DoubleSolenoid::Value::kReverse);
}
void ManipulatorArm::climber(){
	shoulderClimber->Set(frc::DoubleSolenoid::Value::kForward);
	isClimber = true;
}
void ManipulatorArm::shiftToShoulder(){
	shoulderClimber->Set(frc::DoubleSolenoid::Value::kReverse);
	isClimber = false;
}

//***Motion Control***
//These functions are used to get the arm to move to a given position in a certain amount of time
//This function must be called continuously at 50 times a second like the goToDistance code
//Parameters:
//	start - is the starting position of the joint
//		Note: start must remain constant throughout the movement!
//	position - The target position you want the joint to move to
//	current - is the amount of time that has past since this movement started
//		Before you start calling this function record the timestamp with this line of code: Timer::GetFPGATimestamp(); This timestamp must be constant throughout the movement
//		Now current is calculated like this: Timer::GetFPGATimestamp() - [recored timestamp from the beginning];
//	time - is the amount of time you want this motion to take in seconds

//Example say we are in TeleopPeriodic which is called 50 times a second
/*
switch(GoHere) {
	case 0:
		orgFPGA = Timer::GetFPGATimestamp(); //The timestamp at the beginning of the movement
		ShoulderStart = myShoulder->getAngular(); //Get the starting position
		GoHere++; //Go to the next state next time this function is called
		break;
	case 1:
		curTime = Timer::GetFPGATimestamp() - orgFPGA; //Calculate how much time has past
		myShoulder->goToPosition(ShoulderStart, -1000.0, curTime, 3); //Move the shoulder to -1000 in 3 seconds
		if (curTime > 3)
			GoHere++;
		break;
	case 2:
		//End of movement
		break;
}
*/
bool ManipulatorArm::shoulderGoToPosition(double start, double position, double current, double time, bool Rel)
	{
	//multOffset = (Sharpness + (offset - 4)) * 1000;
	double multiplier = (multOffset / (time*1000));
	//Calculate the new set point
	double NewSet = sigmod(position, start, multiplier, posOffset, current);

	//shoulderNewSet = (position - start) * current / time + start;
	if(!Rel)
		setShoulderAbsAngle(NewSet);
	else
		setShoulderRelAngle(NewSet);
	//Return true if the elapse time is complete
	if (current > time)
		{
		if(!Rel)
			setShoulderAbsAngle(position);
		else
			setShoulderRelAngle(position);
		return true;
		}
	return false;
	}

bool ManipulatorArm::elbowGoToPosition(double start, double position, double current, double time, bool Rel)
	{
	//multOffset = (Sharpness + (offset - 4)) * 1000;
	double multiplier = (multOffset / (time*1000));
	//Calculate the new set point
	double NewSet = sigmod(position, start, multiplier, posOffset, current);

	//shoulderNewSet = (position - start) * current / time + start;
	if(!Rel)
		setElbowAbsAngle(NewSet);
	else
		setElbowRelAngle(NewSet);

	//Return true if the elapse time is complete
	if (current > time)
		{
		if(!Rel)
			setElbowAbsAngle(position);
		else
			setElbowRelAngle(position);
		return true;
		}
	return false;
	}

bool ManipulatorArm::wristGoToPosition(double start, double position, double current, double time, bool Rel)
	{
	//multOffset = (Sharpness + (offset - 4)) * 1000;
	double multiplier = (multOffset / (time*1000));
	//Calculate the new set point
	double NewSet = sigmod(position, start, multiplier, posOffset, current);

	//shoulderNewSet = (position - start) * current / time + start;
	if(!Rel)
		setWristAbsAngle(NewSet);
	else
		setWristRelAngle(NewSet);

	//Return true if the elapse time is complete
	if (current > time)
		{
		if(!Rel)
			setWristAbsAngle(position);
		else
			setWristRelAngle(position);
		return true;
		}
	return false;
	}

double ManipulatorArm::sigmod(double end, double start, double mult, double offset, double x)
	{
	return (((end-start)/(1+exp((-(mult*x))+offset)))+start);
	}

double ManipulatorArm::invSigmod(double end, double start, double mult, double offset, double pnt)
    {
    return ((std::log(((end-start)/(pnt-start)) - 1) - offset)/(-mult)); 
    }	
	
//***Convert functions***
void ManipulatorArm::updateArm()
	{
	updateShoulder();
	updateElbow();
	updateWrist();
	updateEndEffector();
	}

void ManipulatorArm::updateShoulder()
	{
	shoulderSeg.encValue = getShoulderAngular();
	frc::SmartDashboard::PutNumber("Shoulder Encoder", shoulderSeg.encValue);
	frc::SmartDashboard::PutNumber("ShEb2", shoulder->GetSensorCollection().GetPulseWidthPosition());
	//Get angles
	shoulderSeg.relAngle = convertEncoderToRelAngle(&shoulderSeg, shoulderSeg.encValue);
	frc::SmartDashboard::PutNumber("Shoulder Relative", shoulderSeg.relAngle);
	shoulderSeg.absAngle = shoulderSeg.relAngle;
	frc::SmartDashboard::PutNumber("Shoulder Absolute", shoulderSeg.absAngle);

	//Read powers
	if(targetPos != currPos)
		{
		double pwr = std::abs(shoulder->GetMotorOutputPercent());
		if(pwr <= 0.25)
			pwrTable[0][0]++;
		else if((pwr > 0.25)||(pwr <= 0.50))
			pwrTable[0][1]++;
		else if((pwr > 0.5)||(pwr <= 0.90))
			pwrTable[0][2]++;
		else if(pwr > 0.9)
			pwrTable[0][3]++;
		}
	}
void ManipulatorArm::updateElbow()
	{
	elbowSeg.encValue = getElbowAngular();
	double elAbsEncoder = elbow->GetSensorCollection().GetPulseWidthPosition();
	//Check for chain skip
	double quadExpected = elAbsEncoder * 4.03436;
	double diff = std::abs(std::abs(elbowSeg.encValue) - quadExpected);
	if((diff > 200)&&(elbow->GetSensorCollection().GetPulseWidthVelocity() == 0))
		{
		frc::SmartDashboard::PutBoolean("Elbow Skipped", true);
		//Auto re-calibrate:
		//elbow->GetSensorCollection().SetQuadraturePosition(-quadExpected, 0);
		//elbowSeg.encValue = getElbowAngular();
		}
	else
		frc::SmartDashboard::PutBoolean("Elbow Skipped", false);

	frc::SmartDashboard::PutNumber("Elbow Encoder", elbowSeg.encValue);
	frc::SmartDashboard::PutNumber("Elbow En Absolute", elbow->GetSensorCollection().GetPulseWidthPosition());
	//Get angles
	elbowSeg.relAngle = convertEncoderToRelAngle(&elbowSeg, elbowSeg.encValue);
	frc::SmartDashboard::PutNumber("Elbow Relative", elbowSeg.relAngle);
	elbowSeg.absAngle = elbowSeg.relAngle + shoulderSeg.absAngle;
	frc::SmartDashboard::PutNumber("Elbow Absolute", elbowSeg.absAngle);
	//Position
	elbowSeg.posX = shoulderSeg.posX + shoulderSeg.length * std::cos(shoulderSeg.absAngle * (M_PI/180));
	//frc::SmartDashboard::PutNumber("Elbow Pos X", elbowSeg.posX);
	elbowSeg.posY = shoulderSeg.posY + shoulderSeg.length * std::sin(shoulderSeg.absAngle * (M_PI/180));
	//frc::SmartDashboard::PutNumber("Elbow Pos Y", elbowSeg.posY);

	if(targetPos != currPos)
		{
		double pwr = std::abs(elbow->GetMotorOutputPercent());
		if(pwr <= 0.25)
			pwrTable[1][0]++;
		else if((pwr > 0.25)||(pwr <= 0.50))
			pwrTable[1][1]++;
		else if((pwr > 0.5)||(pwr <= 0.90))
			pwrTable[1][2]++;
		else if(pwr > 0.9)
			pwrTable[1][3]++;
		}
	}
void ManipulatorArm::updateWrist()
	{
	wristSeg.encValue = getWristAngular();
	frc::SmartDashboard::PutNumber("Wrist Encoder", wristSeg.encValue);
	//Get angles
	wristSeg.relAngle = convertEncoderToRelAngle(&wristSeg, wristSeg.encValue);
	frc::SmartDashboard::PutNumber("Wrist Relative", wristSeg.relAngle);
	wristSeg.absAngle = wristSeg.relAngle + elbowSeg.relAngle + shoulderSeg.absAngle;
	frc::SmartDashboard::PutNumber("Wrist Absolute", wristSeg.absAngle);
	//Position
	wristSeg.posX = elbowSeg.posX + elbowSeg.length * std::cos(elbowSeg.absAngle * (M_PI/180));
	frc::SmartDashboard::PutNumber("Wrist Pos X", wristSeg.posX);
	wristSeg.posY = elbowSeg.posY + elbowSeg.length * std::sin(elbowSeg.absAngle * (M_PI/180));
	frc::SmartDashboard::PutNumber("Wrist Pos Y", wristSeg.posY);

	if(targetPos != currPos)
		{
		double pwr = std::abs(wrist->GetMotorOutputPercent());
		if(pwr <= 0.25)
			pwrTable[2][0]++;
		else if((pwr > 0.25)||(pwr <= 0.50))
			pwrTable[2][1]++;
		else if((pwr > 0.5)||(pwr <= 0.90))
			pwrTable[2][2]++;
		else if(pwr > 0.9)
			pwrTable[2][3]++;
		}
	}	
void ManipulatorArm::updateEndEffector()
	{
	endEffectorX = wristSeg.posX + wristSeg.length * std::cos(wristSeg.absAngle * (M_PI/180));
	frc::SmartDashboard::PutNumber("End Effector X", endEffectorX);
	endEffectorY = wristSeg.posY + wristSeg.length * std::sin(wristSeg.absAngle * (M_PI/180));
	frc::SmartDashboard::PutNumber("End Effector Y", endEffectorY);

	//Check Claw
	frc::SmartDashboard::PutBoolean("Cube In Claw",checkForCube());
	//Check intake
	if((wristSeg.posX > 0) && (wristSeg.posY < 14))
		frc::SmartDashboard::PutBoolean("Intake moveable", false);
	else
		frc::SmartDashboard::PutBoolean("Intake moveable", true);

	//Lights
	if ((endEffectorX > 28) || (endEffectorX < -28))
		{
		if ((endEffectorX > 34) || (endEffectorX < -34))
			{
			lightShowType = 1; //Outside boundary
			posOutTar = targetPos;
			posOutLast = prevPos;
			//frc::SmartDashboard::PutNumber("Out of Bounds Target", posOutTar);
			//frc::SmartDashboard::PutNumber("Out of Bounds Start", posOutLast);
			}
		else
			{
			if (lightShowType == 0)
				lightShowType = 2; //Near Boundary
			}
		}

	}

std::string ManipulatorArm::getPositionStr(int pos)
	{
	std::string str;
	switch(pos)
		{
		case 0:
			str = "Home";
			break;
		case 1:
			str = "Front Scale High";
			break;
		case 2:
			str = "Front Scale Low";
			break;
		case 3:
			str = "Back Scale High";
			break;
		case 4:
			str = "Back Scale Low";
			break;
		case 5:
			str = "Cube Pickup";
			break;
		case 6:
			str = "Portal";
			break;
		case 7:
			str = "Front Switch";
			break;
		case 8:
			str = "Back Switch";
			break;
		case 9:
			str = "Climber";
			break;
		case 10:
			str = "Place Climber";
			break;
		case 11:
			str = "Carry";
			break;
		case 12:
			str = "Climbing";
			break;
		}
	return str;
	}

bool ManipulatorArm::checkForCube()
	{
	return cubeDetector->Get() ^ 1;
	}

double ManipulatorArm::convertEncoderToRelAngle(tpArmSegment *Seg, double encoder)
	{
	return (encoder * Seg->convSlope + Seg->convIntercept);
	}
double ManipulatorArm::convertRelAngleToEncoder(tpArmSegment *Seg, double angle)
	{
	return (((angle) - (Seg->convIntercept))/(Seg->convSlope));
	}

void ManipulatorArm::openLog()
	{
	time_t t=time(0);
	struct tm *now;
	now = localtime(&t);

	if(!logfile.is_open())
		{
		sprintf(buf,"/media/sda1/ARM%02d%02d%02d%02d%02d%02d.txt",now->tm_year,now->tm_mon,now->tm_mday,now->tm_hour,now->tm_min,now->tm_sec);
		logfile.open(buf,std::ios::out | std::ios::binary);
		}
	else
		{
		sprintf(buf,"/media/sdb1/LL%02d%02d%02d%02d%02d%02d.txt",now->tm_year,now->tm_mon,now->tm_mday,now->tm_hour,now->tm_min,now->tm_sec);
		logfile.open(buf,std::ios::out | std::ios::binary);
		}
	}
void ManipulatorArm::closeLog()
	{
	if (logfile.is_open())
		logfile.close();
	}
// Put methods for controlling this subsystem
// here. Call these from Commands.

